<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äº¡çµä¸»å®°ï¼šæœ€ç»ˆå†³æˆ˜</title>
    <style>
        :root {
            --bg: #130f1a;
            --accent: #9b59b6; /* å·«å¸ˆç´« */
            --minion: #2ecc71;  /* å‚€å„¡ç»¿ */
            --enemy: #e74c3c;   /* æ•Œäººçº¢ */
            --ui-bg: rgba(0, 0, 0, 0.7);
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none;
            color: white;
        }

        canvas { display: block; }

        /* UI å®¹å™¨ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* é¡¶éƒ¨ HUD */
        .hud {
            padding: 15px; display: flex; flex-direction: column; gap: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }
        .top-row { display: flex; justify-content: space-between; align-items: center; }
        
        /* ç»éªŒæ¡ */
        .xp-container {
            width: 100%; height: 8px; background: #333; border-radius: 4px;
            overflow: hidden; margin-top: 5px; border: 1px solid #555;
        }
        #xp-bar { width: 0%; height: 100%; background: #f1c40f; transition: width 0.2s; }

        .stat-box {
            background: var(--ui-bg); padding: 6px 12px; border-radius: 15px;
            border: 1px solid #555; font-weight: bold; font-size: 0.9rem;
            display: flex; align-items: center; gap: 5px;
        }

        /* å€’è®¡æ—¶ */
        .timer-box {
            position: absolute; top: 60px; width: 100%; text-align: center;
            font-size: 1.5rem; font-weight: bold; text-shadow: 0 2px 4px #000;
            pointer-events: none;
        }

        /* åº•éƒ¨æ“ä½œåŒº */
        .controls {
            margin-top: auto; padding: 20px; display: flex; justify-content: space-between;
            align-items: flex-end; pointer-events: auto;
        }

        /* æ‘‡æ† */
        #joystick-zone { width: 140px; height: 140px; position: relative; }
        #stick-bg {
            position: absolute; width: 90px; height: 90px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            top: 25px; left: 25px;
        }
        #stick {
            position: absolute; width: 40px; height: 40px; border-radius: 50%;
            background: var(--accent); top: 50px; left: 50px;
            box-shadow: 0 0 10px var(--accent);
        }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: flex; gap: 15px; margin-bottom: 10px; }
        .action-btn {
            width: 75px; height: 75px; border-radius: 50%; border: none;
            background: rgba(255,255,255,0.15); color: white; font-size: 1.8rem;
            backdrop-filter: blur(5px); border: 2px solid rgba(255,255,255,0.5);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: transform 0.1s; position: relative;
        }
        .action-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.4); }
        
        #btn-tame { border-color: var(--accent); color: var(--accent); }
        #btn-tame.active { background: var(--accent); color: #fff; box-shadow: 0 0 25px var(--accent); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%{transform:scale(1);} 50%{transform:scale(1.05);} 100%{transform:scale(1);} }

        #btn-cmd { border-color: var(--minion); color: var(--minion); }
        .btn-label { font-size: 0.7rem; margin-top: -5px; font-weight: bold; }

        /* å‡çº§å¡ç‰‡å¼¹çª— */
        #upgrade-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; pointer-events: auto;
        }
        .card-container { display: flex; flex-direction: column; gap: 15px; width: 85%; max-width: 400px; }
        .card {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            border: 2px solid var(--accent); border-radius: 15px; padding: 15px;
            display: flex; align-items: center; gap: 15px; cursor: pointer;
            transition: transform 0.2s;
        }
        .card:active { transform: scale(0.95); background: var(--accent); }
        .card-icon { font-size: 2.5rem; }
        .card-info h3 { margin: 0 0 5px 0; color: #f1c40f; font-size: 1.1rem; }
        .card-info p { margin: 0; font-size: 0.8rem; color: #ccc; }

        /* ç»“ç®—/å¼€å§‹ç•Œé¢ */
        #full-screen-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #130f1a; z-index: 300; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .btn-main {
            background: var(--accent); padding: 15px 50px; border-radius: 30px;
            font-size: 1.5rem; border: none; color: white; margin-top: 30px;
            font-weight: bold; box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        .diff-select { margin-top: 20px; display: flex; gap: 10px; }
        .diff-opt { 
            padding: 10px 20px; border: 2px solid #555; border-radius: 10px; 
            color: #888; font-weight: bold;
        }
        .diff-opt.selected { border-color: var(--accent); color: var(--accent); background: rgba(155,89,182,0.1); }

        /* é£˜å­— */
        .float-txt { position: absolute; font-weight: bold; pointer-events: none; animation: flyUp 1s forwards; text-shadow: 1px 1px 0 #000; }
        @keyframes flyUp { 100% { transform: translateY(-40px); opacity: 0; } }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div class="top-row">
                <div class="stat-box" style="border-color: #ff6b6b;">â¤ï¸ <span id="hp-val">100</span></div>
                <div class="stat-box" style="border-color: var(--minion);">
                    ğŸ§Ÿ <span id="army-val">0</span>/<span id="cap-val">3</span>
                </div>
                <div class="stat-box">LV <span id="lvl-val">1</span></div>
            </div>
            <div class="xp-container"><div id="xp-bar"></div></div>
        </div>

        <div class="timer-box" id="timer-display">05:00</div>

        <div class="controls">
            <div id="joystick-zone">
                <div id="stick-bg"></div>
                <div id="stick"></div>
            </div>

            <div class="btn-group">
                <button class="action-btn" id="btn-cmd" onclick="Game.toggleCommand()">
                    <span id="cmd-icon">ğŸ›¡ï¸</span>
                    <span class="btn-label" id="cmd-text">è·Ÿéš</span>
                </button>
                <button class="action-btn" id="btn-tame">
                    âœ¨
                    <span class="btn-label">è½¬åŒ–</span>
                </button>
            </div>
        </div>
    </div>

    <div id="upgrade-modal">
        <h2 style="color:#fff; margin-bottom:20px;">çµé­‚å‡å (Level Up!)</h2>
        <div class="card-container" id="cards-box"></div>
    </div>

    <div id="full-screen-modal">
        <h1 id="modal-title" style="font-size: 2.5rem; color: var(--accent); margin-bottom: 10px;">äº¡çµä¸»å®°</h1>
        <p id="modal-desc" style="color:#aaa; max-width: 80%; text-align: center;">
            æ•è·åƒµå°¸ï¼Œç»„å»ºå†›é˜Ÿï¼Œå‡»è´¥5åˆ†é’Ÿåçš„å°¸ç‹
        </p>
        
        <div class="diff-select" id="diff-box">
            <div class="diff-opt selected" onclick="Game.setDiff('normal')">æ™®é€š</div>
            <div class="diff-opt" onclick="Game.setDiff('hard')">åœ°ç‹±</div>
        </div>

        <button class="btn-main" onclick="Game.start()">å¼€å§‹å¬å”¤</button>
    </div>

    <script>
        // --- ğŸ”Š éŸ³æ•ˆ ---
        const AudioSys = {
            ctx: null,
            init() { if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol=0.1) {
                if(!this.ctx) return; if(this.ctx.state==='suspended') this.ctx.resume();
                const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
                o.type=type; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+duration);
                o.connect(g); g.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime+duration);
            },
            playBeam() { this.playTone(150+Math.random()*50, 'sawtooth', 0.1, 0.05); },
            playTame() { this.playTone(600,'sine',0.1,0.2); setTimeout(()=>this.playTone(1000,'sine',0.3,0.2),100); },
            playXp() { this.playTone(800,'triangle',0.1,0.05); },
            playWin() { 
                [523,659,783,1046].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.5,0.1),i*150));
            }
        };

        // --- ğŸ› ï¸ æ¸¸æˆæ ¸å¿ƒ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let WIDTH, HEIGHT;

        const Game = {
            state: 'menu',
            frames: 0, time: 300, // 5åˆ†é’Ÿå€’è®¡æ—¶
            player: null, entities: [], particles: [], items: [],
            camX: 0, camY: 0,
            
            // ç©å®¶å±æ€§
            maxMinions: 3,
            tamePower: 1,      // è½¬åŒ–é€Ÿåº¦
            beamCount: 1,      // åŒæ—¶è½¬åŒ–æ•°é‡
            minionBuff: { hp: 1.5, dmg: 1.2, size: 1.2 }, // å‚€å„¡å¢å¼ºå€ç‡
            
            // çŠ¶æ€
            command: 'FOLLOW',
            isTaming: false,
            targets: [],
            
            // éš¾åº¦
            difficulty: 'normal',
            waveInterval: 60,
            
            // å‡çº§æ± 
            upgrades: [
                { id: 'multi_beam', name: 'å¤šé‡æ–½æ³•', desc: 'åŒæ—¶è½¬åŒ–æ•°é‡ +1', icon: 'ğŸ”®', rare: true },
                { id: 'fast_tame', name: 'çµé­‚è™¹å¸', desc: 'è½¬åŒ–é€Ÿåº¦ +30%', icon: 'âš¡' },
                { id: 'army_cap', name: 'ç»Ÿå¾¡æ„å¿—', desc: 'æœ€å¤§æ§åˆ¶ä¸Šé™ +2', icon: 'ğŸ‘‘', rare: true },
                { id: 'minion_hp', name: 'äº¡çµåšéŸ§', desc: 'å‚€å„¡ç”Ÿå‘½ +50%', icon: 'ğŸ›¡ï¸' },
                { id: 'minion_dmg', name: 'ç‹‚æš´å…‰ç¯', desc: 'å‚€å„¡æ”»å‡» +30%', icon: 'âš”ï¸' },
                { id: 'self_heal', name: 'ç”Ÿå‘½æ±²å–', desc: 'å›å¤ 30% ç”Ÿå‘½å€¼', icon: 'â¤ï¸' }
            ],

            setDiff(d) {
                this.difficulty = d;
                // åˆ‡æ¢é€‰ä¸­æ ·å¼ï¼ˆé€šè¿‡ç´¢å¼•æ˜ å°„ï¼‰
                const opts = document.querySelectorAll('.diff-opt');
                opts.forEach(e => e.classList.remove('selected'));
                if (d === 'normal') {
                    if (opts[0]) opts[0].classList.add('selected');
                } else {
                    if (opts[1]) opts[1].classList.add('selected');
                }
            },

            // æ–°å¢ï¼šå¤„ç†ç”»å¸ƒå°ºå¯¸ä¸ DPR ç¼©æ”¾
            resize() {
                const dpr = window.devicePixelRatio || 1;
                // CSS å°ºå¯¸ï¼ˆé€»è¾‘åƒç´ ï¼‰
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                // ç‰©ç†åƒç´ 
                canvas.style.width = WIDTH + 'px';
                canvas.style.height = HEIGHT + 'px';
                canvas.width = Math.round(WIDTH * dpr);
                canvas.height = Math.round(HEIGHT * dpr);
                // é‡ç½® transform å¹¶æŒ‰ DPR ç¼©æ”¾ï¼ˆé¿å…é‡å¤ scale ç´¯åŠ ï¼‰
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                // å¦‚æœç©å®¶å°šæœªåˆå§‹åŒ–ï¼ŒæŠŠç©å®¶æ”¾åœ¨å±å¹•ä¸­å¿ƒï¼ˆä¾¿äºå¼€å§‹ç•Œé¢é¢„è§ˆï¼‰
                if (!this.player) {
                    // å¸®åŠ©å¼€å§‹æ—¶å±…ä¸­
                    this.camX = 0;
                    this.camY = 0;
                } else {
                    // ä¿æŒç©å®¶åœ¨å±å¹•ä¸­å¤®
                    this.camX = this.player.x - WIDTH / 2;
                    this.camY = this.player.y - HEIGHT / 2;
                }

                // æ›´æ–°æµ®åŠ¨æ–‡æœ¬ä½ç½®æ—¶ä¼šç”¨åˆ° WIDTH/HEIGHT
            },

            start() {
                AudioSys.init();
                document.getElementById('full-screen-modal').style.display = 'none';
                this.state = 'playing';
                this.resize();
                
                // åˆå§‹åŒ–
                const startHp = this.difficulty === 'hard' ? 60 : 100;
                this.player = new Player(0, 0, startHp);
                // æŠŠç©å®¶æ”¾åœ¨ä¸–ç•Œä¸­å¿ƒï¼ˆ0,0ï¼‰
                this.player.x = 0;
                this.player.y = 0;
                this.entities = [];
                this.particles = [];
                this.items = [];
                this.frames = 0;
                this.time = 300; 
                
                // é‡ç½®å‡çº§å±æ€§
                this.maxMinions = this.difficulty === 'hard' ? 2 : 3;
                this.beamCount = 1;
                this.tamePower = 1;
                this.minionBuff = { hp: 1.5, dmg: 1.2, size: 1.2 };
                this.updateUI();

                this.loop();
                
                // è®¡æ—¶å™¨
                if(this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if(this.state === 'playing') {
                        this.time--;
                        this.updateTimer();
                        if(this.time === 0) this.spawnBoss();
                    }
                }, 1000);
            },

            loop() {
                if(this.state !== 'playing') return;
                this.frames++;

                // 1. ç”Ÿæˆé€»è¾‘
                this.spawnLogic();

                // 2. æ›´æ–°å®ä½“
                if (this.player) this.player.update();
                if (this.player) {
                    this.camX += (this.player.x - WIDTH/2 - this.camX) * 0.1;
                    this.camY += (this.player.y - HEIGHT/2 - this.camY) * 0.1;
                }

                this.entities.forEach(e => e.update && e.update());
                this.items.forEach(i => i.update && i.update());
                this.particles.forEach(p => p.update && p.update());
                
                // æ’åºæ¸²æŸ“
                this.entities.sort((a,b) => a.y - b.y);

                // 3. æ¸…ç†
                this.entities = this.entities.filter(e => !e.dead);
                this.items = this.items.filter(i => !i.collected);
                this.particles = this.particles.filter(p => p.life > 0);

                // 4. è½¬åŒ–
                if(this.isTaming) this.handleTaming();
                else this.targets = [];

                this.draw();
                requestAnimationFrame(() => this.loop());
            },

            spawnLogic() {
                // åŠ¨æ€éš¾åº¦
                let rate = this.difficulty === 'hard' ? 40 : 60;
                // éšæ—¶é—´åŠ å¿«
                rate = Math.max(15, rate - Math.floor((300 - this.time)/20));
                
                const enemies = this.entities.filter(e => e.team === 'wild').length;
                const cap = 15 + Math.floor((300-this.time)/10); // éšæ—¶é—´ä¸Šé™å¢åŠ 

                if (this.frames % rate === 0 && enemies < cap && this.time > 0) {
                    this.spawnEnemy();
                }
            },

            spawnEnemy() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(WIDTH,HEIGHT)*0.7 + Math.random()*200;
                const x = this.player.x + Math.cos(angle)*dist;
                const y = this.player.y + Math.sin(angle)*dist;
                
                // éšæœºç±»å‹
                const r = Math.random();
                let type = 'NORMAL';
                if(r<0.15) type='TANK'; else if(r<0.3) type='SPEED'; else if(r<0.45) type='BOOM';
                
                this.entities.push(new Zombie(x, y, 'wild', type));
            },

            spawnBoss() {
                // 5åˆ†é’Ÿåˆ°ï¼Œå‡ºBOSS
                const angle = Math.random() * Math.PI * 2;
                const x = this.player.x + Math.cos(angle)*400;
                const y = this.player.y + Math.sin(angle)*400;
                const boss = new Zombie(x, y, 'wild', 'BOSS');
                this.entities.push(boss);
                showText(x, y, "ğŸ’€ ç¼åˆå·¨æ€ªé™ä¸´!", "#e74c3c");
            },

            handleTaming() {
                // å¯»æ‰¾è§†é‡å†…æœ€è¿‘çš„Nä¸ªæ•Œäºº
                let candidates = this.entities.filter(e => e.team === 'wild' && !e.dead && e.type !== 'BOSS');
                // æŒ‰è·ç¦»æ’åº
                candidates.sort((a, b) => {
                    const da = Math.hypot(a.x - this.player.x, a.y - this.player.y);
                    const db = Math.hypot(b.x - this.player.x, b.y - this.player.y);
                    return da - db;
                });

                // é€‰å–å‰Nä¸ª (æ ¹æ®beamCount)
                this.targets = candidates.slice(0, this.beamCount).filter(e => Math.hypot(e.x-this.player.x, e.y-this.player.y) < 300);

                if (this.targets.length > 0) {
                    if(this.frames % 4 === 0) AudioSys.playBeam(); // è¿ç»­éŸ³æ•ˆ
                    
                    this.targets.forEach(t => {
                        let rate = 1.0 * this.tamePower;
                        if(t.type === 'TANK') rate *= 0.6;
                        
                        t.tameProgress += rate;
                        t.speed *= 0.3; // è¢«æ§åˆ¶å‡é€Ÿ
                        
                        if (t.tameProgress >= 100) {
                            this.convertZombie(t);
                        }
                    });
                }
            },

            convertZombie(target) {
                const minions = this.entities.filter(e => e.team === 'minion').length;
                if (minions >= this.maxMinions) {
                    showText(this.player.x, this.player.y-30, "å†›é˜Ÿå·²æ»¡!", "#ff6b6b");
                    // çŒ®ç¥­å›è¡€
                    target.takeDamage(9999);
                    this.player.heal(10);
                    return;
                }

                target.team = 'minion';
                target.tameProgress = 0;
                
                // å¢å¼ºå±æ€§
                target.maxHp *= this.minionBuff.hp;
                target.hp = target.maxHp;
                target.dmg *= this.minionBuff.dmg;
                target.r *= this.minionBuff.size; // å˜å¤§

                AudioSys.playTame();
                createParticles(target.x, target.y, '#2ecc71', 20);
                showText(target.x, target.y-20, "è½¬åŒ–å®Œæˆ!", "#2ecc71");
                this.updateUI();
            },

            toggleCommand() {
                this.command = this.command === 'FOLLOW' ? 'ATTACK' : 'FOLLOW';
                const btn = document.getElementById('btn-cmd');
                const icon = document.getElementById('cmd-icon');
                const text = document.getElementById('cmd-text');
                if (this.command === 'ATTACK') {
                    icon.innerText = 'âš”ï¸'; text.innerText = 'å…¨å†›å‡ºå‡»';
                    btn.style.borderColor = '#e74c3c'; btn.style.color = '#e74c3c';
                } else {
                    icon.innerText = 'ğŸ›¡ï¸'; text.innerText = 'æŠ¤å«ä¸»äºº';
                    btn.style.borderColor = '#2ecc71'; btn.style.color = '#2ecc71';
                }
            },

            checkWin(boss) {
                if (boss.type === 'BOSS' && boss.dead) {
                    this.endGame(true);
                }
            },

            levelUp() {
                this.state = 'paused';
                const box = document.getElementById('cards-box');
                box.innerHTML = '';
                
                // éšæœº3ä¸ª
                const pool = [...this.upgrades];
                const choices = [];
                for(let i=0; i<3; i++) {
                    const idx = Math.floor(Math.random()*pool.length);
                    choices.push(pool[idx]);
                }

                choices.forEach(u => {
                    const div = document.createElement('div'); div.className = 'card';
                    div.innerHTML = `<div class="card-icon">${u.icon}</div><div class="card-info"><h3>${u.name}</h3><p>${u.desc}</p></div>`;
                    div.onclick = () => {
                        this.applyUpgrade(u.id);
                        document.getElementById('upgrade-modal').style.display = 'none';
                        this.state = 'playing';
                        this.loop();
                    };
                    box.appendChild(div);
                });

                document.getElementById('upgrade-modal').style.display = 'flex';
            },

            applyUpgrade(id) {
                if (id === 'multi_beam') this.beamCount++;
                if (id === 'fast_tame') this.tamePower *= 1.3;
                if (id === 'army_cap') this.maxMinions += 2;
                if (id === 'minion_hp') {
                    this.minionBuff.hp *= 1.5;
                    this.entities.filter(e=>e.team==='minion').forEach(e=>{ e.maxHp*=1.5; e.hp+=50; });
                }
                if (id === 'minion_dmg') {
                    this.minionBuff.dmg *= 1.3;
                    this.entities.filter(e=>e.team==='minion').forEach(e=>e.dmg*=1.3);
                }
                if (id === 'self_heal' && this.player) this.player.heal(this.player.maxHp * 0.3);
                
                this.updateUI();
            },

            endGame(win) {
                this.state = 'over';
                const modal = document.getElementById('full-screen-modal');
                const title = document.getElementById('modal-title');
                const desc = document.getElementById('modal-desc');
                const btn = modal.querySelector('.btn-main');
                const diffBox = document.getElementById('diff-box');

                modal.style.display = 'flex';
                diffBox.style.display = 'none';
                
                if(win) {
                    title.innerText = "ğŸ‘‘ äº¡çµä¸»å®°é™ä¸´";
                    title.style.color = "#f1c40f";
                    desc.innerText = "ä½ å‡»è´¥äº†ç¼åˆå·¨æ€ªï¼Œæ•´ä¸ªè’åŸéƒ½åœ¨ä½ çš„è„šä¸‹é¢¤æŠ–ï¼";
                    btn.innerText = "å†æ¬¡ç»Ÿæ²»";
                    AudioSys.playWin();
                } else {
                    title.innerText = "âš°ï¸ ä½ çš„ä¼ è¯´ç»“æŸäº†";
                    title.style.color = "#7f8c8d";
                    desc.innerText = "å³ä½¿å€’ä¸‹ï¼Œä½ çš„åå­—ä¾ç„¶è®©ç”Ÿè€…ç•æƒ§ã€‚";
                    btn.innerText = "å†æ¬¡å¤æ´»";
                }
            },

            draw() {
                ctx.fillStyle = '#130f1a'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.save(); ctx.translate(-this.camX, -this.camY);
                
                // ç½‘æ ¼
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                const gs = 100;
                const sx = Math.floor(this.camX/gs)*gs; const sy = Math.floor(this.camY/gs)*gs;
                for(let x=sx; x<sx+WIDTH+gs; x+=gs) { ctx.beginPath(); ctx.moveTo(x,sy); ctx.lineTo(x,sy+HEIGHT+gs); ctx.stroke(); }
                for(let y=sy; y<sy+HEIGHT+gs; y+=gs) { ctx.beginPath(); ctx.moveTo(sx,y); ctx.lineTo(sx+WIDTH+gs,y); ctx.stroke(); }

                // å…‰æŸ
                this.targets.forEach(t => {
                    ctx.beginPath(); ctx.moveTo(this.player.x, this.player.y); ctx.lineTo(t.x, t.y);
                    ctx.strokeStyle = '#9b59b6'; ctx.lineWidth = 3 + Math.random()*3; ctx.stroke();
                });

                this.items.forEach(i => i.draw());
                this.entities.forEach(e => e.draw());
                if (this.player) this.player.draw();
                this.particles.forEach(p => p.draw());
                
                ctx.restore();
            },
            
            updateTimer() {
                const m = Math.floor(this.time/60); const s = this.time%60;
                document.getElementById('timer-display').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            },
            updateUI() {
                if (!this.player) return;
                document.getElementById('hp-val').innerText = Math.floor(this.player.hp);
                const cnt = this.entities.filter(e=>e.team==='minion').length;
                document.getElementById('army-val').innerText = cnt;
                document.getElementById('cap-val').innerText = this.maxMinions;
                document.getElementById('lvl-val').innerText = this.player.lvl;
                document.getElementById('xp-bar').style.width = (this.player.xp/this.player.maxXp*100)+'%';
            }
        };

        // --- å®ä½“ç±» ---
        class Entity {
            constructor(x, y, r, color) {
                this.x = x; this.y = y; this.r = r; this.color = color; this.dead = false;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
            }
        }

        class Player extends Entity {
            constructor(x, y, maxHp) {
                super(x, y, 15, '#9b59b6');
                this.speed = 4; this.maxHp = maxHp; this.hp = maxHp;
                this.xp = 0; this.maxXp = 20; this.lvl = 1;
            }
            update() {
                let spd = this.speed;
                if (Game.isTaming && Game.targets.length > 0) spd *= 0.3; // æ–½æ³•å‡é€Ÿ
                if (joystick.active) { this.x += joystick.x * spd; this.y += joystick.y * spd; }
            }
            gainXp(val) {
                this.xp += val;
                if (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp; this.lvl++; this.maxXp *= 1.3;
                    Game.levelUp();
                }
                Game.updateUI();
            }
            heal(amt) { this.hp = Math.min(this.maxHp, this.hp + amt); Game.updateUI(); showText(this.x, this.y-20, "+HP", "#2ecc71"); }
            takeDamage(amt) {
                this.hp -= amt; Game.updateUI(); createParticles(this.x, this.y, '#fff', 3);
                if (this.hp <= 0) Game.endGame(false);
            }
            draw() {
                ctx.strokeStyle = 'rgba(155, 89, 182, 0.2)'; ctx.beginPath(); ctx.arc(this.x, this.y, 250, 0, Math.PI*2); ctx.stroke();
                super.draw();
                ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.fillText('ğŸ§™â€â™‚ï¸', this.x-6, this.y+4);
            }
        }

        class Zombie extends Entity {
            constructor(x, y, team, type) {
                super(x, y, 12, '#e74c3c');
                this.team = team; this.type = type;
                this.tameProgress = 0; this.cd = 0; this.maxCd = 40;
                
                if(type==='NORMAL') { this.hp=30; this.dmg=5; this.speedBase=1.8; }
                if(type==='TANK') { this.hp=120; this.dmg=10; this.speedBase=1.2; this.r=18; this.color='#8e44ad'; }
                if(type==='SPEED') { this.hp=20; this.dmg=4; this.speedBase=3.0; this.r=10; this.color='#f1c40f'; }
                if(type==='BOOM') { this.hp=25; this.dmg=60; this.speedBase=2.2; this.color='#e67e22'; }
                if(type==='BOSS') { this.hp=3000; this.dmg=30; this.speedBase=1.5; this.r=40; this.color='#c0392b'; }
                
                this.maxHp = this.hp; this.speed = this.speedBase;
            }
            update() {
                if (this.cd > 0) this.cd--;
                this.speed = this.speedBase;

                // ç´¢æ•Œé€»è¾‘
                let target = null;
                
                // é‡ç”Ÿ/BOSSï¼šä¼˜å…ˆæ‰“ç©å®¶
                if (this.team === 'wild') {
                    target = Game.player;
                    // å¦‚æœè¢«éšä»è´´è„¸ï¼Œè½¬ç«
                    let nearestMinion = null; let minDist = 60;
                    Game.entities.forEach(e => {
                        if(e.team === 'minion') {
                            const d = Math.hypot(e.x-this.x, e.y-this.y);
                            if(d < minDist) { minDist=d; nearestMinion=e; }
                        }
                    });
                    if(nearestMinion) target = nearestMinion;
                } 
                // éšä»
                else {
                    if (Game.command === 'FOLLOW') {
                        const dp = Math.hypot(Game.player.x-this.x, Game.player.y-this.y);
                        if(dp > 100) target = Game.player;
                        else {
                            let minD = 200;
                            Game.entities.filter(e=>e.team==='wild').forEach(e=>{
                                const d = Math.hypot(e.x-this.x, e.y-this.y);
                                if(d<minD) { minD=d; target=e; }
                            });
                        }
                    } else {
                        let minD = 600;
                        Game.entities.filter(e=>e.team==='wild').forEach(e=>{
                            const d = Math.hypot(e.x-this.x, e.y-this.y);
                            if(d<minD) { minD=d; target=e; }
                        });
                    }
                }

                if (target) {
                    const dx = target.x - this.x; const dy = target.y - this.y;
                    const d = Math.hypot(dx, dy);
                    
                    // é¿è®©
                    Game.entities.forEach(e => {
                        if(e!==this && !e.dead) {
                            const dist = Math.hypot(e.x-this.x, e.y-this.y);
                            if(dist < this.r+e.r) { this.x-=(e.x-this.x)*0.05; this.y-=(e.y-this.y)*0.05; }
                        }
                    });

                    if (d > this.r + (target.r || 0) + 5) {
                        this.x += (dx/d) * this.speed; this.y += (dy/d) * this.speed;
                    } else {
                        // æ”»å‡»
                        if (this.type === 'BOOM' && (this.team !== target.team)) this.explode();
                        else if (this.cd <= 0) {
                            if (typeof target.takeDamage === 'function') target.takeDamage(this.dmg);
                            this.cd = this.maxCd;
                        }
                    }
                }
            }
            takeDamage(amt) {
                this.hp -= amt;
                createParticles(this.x, this.y, this.color, 2);
                if (this.hp <= 0) {
                    this.dead = true;
                    if (this.team === 'wild') {
                        // æ‰è½ç»éªŒ
                        Game.items.push(new Item(this.x, this.y));
                        if(this.type==='BOSS') Game.checkWin(this);
                    }
                }
            }
            explode() {
                this.dead = true; createParticles(this.x, this.y, '#e67e22', 20);
                const range = 120;
                [...Game.entities, Game.player].forEach(e => {
                    if(!e || e.dead) return;
                    if(Math.hypot(e.x-this.x, e.y-this.y) < range) {
                        if(e.team !== this.team && typeof e.takeDamage === 'function') e.takeDamage(this.dmg);
                        else if(typeof e.takeDamage === 'function') e.takeDamage(this.dmg * 0.2);
                    }
                });
            }
            draw() {
                ctx.fillStyle = this.team === 'minion' ? '#2ecc71' : this.color;
                
                // é€‰ä¸­é«˜äº®
                if (Game.targets.includes(this)) {
                    ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r+5, 0, Math.PI*2); ctx.stroke();
                }
                
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                
                // è¡€æ¡
                ctx.fillStyle = '#c0392b'; ctx.fillRect(this.x-12, this.y-this.r-8, 24, 4);
                ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x-12, this.y-this.r-8, 24*(this.hp/this.maxHp), 4);
                
                // è½¬åŒ–æ¡
                if (this.tameProgress > 0) {
                    ctx.fillStyle = '#9b59b6'; ctx.fillRect(this.x-12, this.y-this.r-14, 24*(this.tameProgress/100), 4);
                }

                // æ ‡è®°
                let icon = '';
                if(this.type==='TANK') icon='ğŸ›¡ï¸'; if(this.type==='SPEED') icon='âš¡'; if(this.type==='BOOM') icon='ğŸ’£'; if(this.type==='BOSS') icon='ğŸ‘¹';
                if(icon) { ctx.fillStyle='#fff'; ctx.font='12px Arial'; ctx.fillText(icon, this.x-6, this.y+5); }
            }
        }

        class Item {
            constructor(x, y) {
                this.x = x; this.y = y; this.bob = Math.random(); this.collected = false;
            }
            update() {
                this.bob += 0.1;
                // å¸é™„
                const d = Math.hypot(this.x-Game.player.x, this.y-Game.player.y);
                if(d < 100) {
                    this.x += (Game.player.x - this.x) * 0.1;
                    this.y += (Game.player.y - this.y) * 0.1;
                }
                if(d < 20) { this.collected = true; AudioSys.playXp(); Game.player.gainXp(5); }
            }
            draw() {
                const y = this.y + Math.sin(this.bob)*5;
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(this.x, y, 5, 0, Math.PI*2); ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, c, n) { this.x=x; this.y=y; this.c=c; this.vx=(Math.random()-0.5)*5; this.vy=(Math.random()-0.5)*5; this.life=20; }
            update() { this.x+=this.vx; this.y+=this.vy; this.life--; }
            draw() { ctx.globalAlpha=this.life/20; ctx.fillStyle=this.c; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha=1; }
        }

        // --- äº¤äº’ ---
        const tameBtn = document.getElementById('btn-tame');
        const startTame = (e) => { e.preventDefault(); Game.isTaming = true; tameBtn.classList.add('active'); };
        const endTame = (e) => { e.preventDefault(); Game.isTaming = false; tameBtn.classList.remove('active'); };
        tameBtn.addEventListener('touchstart', startTame); tameBtn.addEventListener('touchend', endTame);
        tameBtn.addEventListener('mousedown', startTame); tameBtn.addEventListener('mouseup', endTame);

        const stick = document.getElementById('stick');
        const zone = document.getElementById('joystick-zone');
        const joystick = { x: 0, y: 0, active: false, originX: 0, originY: 0 };

        zone.addEventListener('touchstart', e => {
            e.preventDefault(); const t = e.touches[0]; joystick.active = true;
            const r = zone.getBoundingClientRect();
            joystick.originX = r.left + r.width/2; joystick.originY = r.top + r.height/2;
            updateStick(t.clientX, t.clientY);
        }, {passive:false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault(); if(joystick.active) updateStick(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive:false});

        const resetStick = () => { joystick.active = false; joystick.x=0; joystick.y=0; stick.style.left='50px'; stick.style.top='50px'; };
        zone.addEventListener('touchend', resetStick); zone.addEventListener('touchcancel', resetStick);

        function updateStick(cx, cy) {
            const max = 45; let dx = cx - joystick.originX, dy = cy - joystick.originY;
            const d = Math.hypot(dx, dy); if(d > max) { dx *= max/d; dy *= max/d; }
            stick.style.left = (50+dx)+'px'; stick.style.top = (50+dy)+'px';
            joystick.x = dx/max; joystick.y = dy/max;
        }

        function createParticles(x, y, c, n) { for(let i=0; i<n; i++) Game.particles.push(new Particle(x, y, c)); }
        function showText(x, y, txt, c) {
            const el = document.createElement('div'); el.className = 'float-txt';
            el.innerText = txt; el.style.color = c;
            // DOM åæ ‡ä¿®æ­£
            const r = canvas.getBoundingClientRect();
            const sx = (x - Game.camX) + WIDTH/2;
            const sy = (y - Game.camY) + HEIGHT/2;
            
            // åªæœ‰åœ¨å±å¹•å†…çš„æ‰æ˜¾ç¤º
            if(sx>0 && sx<WIDTH && sy>0 && sy<HEIGHT) {
                el.style.left = sx + 'px'; el.style.top = sy + 'px';
                document.body.appendChild(el); setTimeout(()=>el.remove(), 1000);
            }
        }

        window.addEventListener('resize', () => Game.resize());
        // é¦–æ¬¡è®¾ç½®ç”»å¸ƒå¤§å°
        Game.resize();

    </script>
</body>
</html>
