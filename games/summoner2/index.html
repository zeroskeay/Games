<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äº¡çµä¸»å®°ï¼šå¬å”¤å¸ˆå´›èµ·</title>
    <style>
        :root {
            --bg: #200f21;
            --accent: #b98eff;
            --item-rare: #00d2d3;
            --item-heal: #ff6b6b;
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none;
            color: white;
        }

        canvas { display: block; }

        /* UIå±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* HUD */
        .hud {
            padding: 15px; display: flex; justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }
        .stat-box {
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid #555; font-weight: bold; display: flex; align-items: center; gap: 5px;
            font-size: 0.9rem;
        }

        /* æ“ä½œåŒº */
        .controls {
            margin-top: auto; padding: 20px; display: flex; justify-content: space-between;
            align-items: flex-end; pointer-events: auto;
        }

        #joystick-zone { width: 150px; height: 150px; position: relative; }
        #stick-bg {
            position: absolute; width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            top: 25px; left: 25px;
        }
        #stick {
            position: absolute; width: 40px; height: 40px; border-radius: 50%;
            background: var(--accent); top: 55px; left: 55px;
            box-shadow: 0 0 10px var(--accent);
        }

        .btn-group { display: flex; gap: 15px; margin-bottom: 20px; }
        .action-btn {
            width: 75px; height: 75px; border-radius: 50%; border: none;
            background: rgba(255,255,255,0.1); color: white; font-size: 1.8rem;
            backdrop-filter: blur(5px); border: 2px solid #fff;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: transform 0.1s; position: relative;
        }
        .action-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }
        
        #btn-tame { border-color: var(--accent); color: var(--accent); }
        #btn-tame.active { background: var(--accent); color: #fff; box-shadow: 0 0 25px var(--accent); }
        #btn-cmd { border-color: #0be881; color: #0be881; }
        .btn-label { font-size: 0.7rem; margin-top: -5px; font-weight: bold; }

        /* å¼€å§‹å±å¹• */
        #start-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(32, 15, 33, 0.95); z-index: 200; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .title { font-size: 2.5rem; color: var(--accent); margin-bottom: 40px; text-shadow: 0 0 20px var(--accent); }
        .diff-btn {
            width: 220px; padding: 15px; margin: 10px; border-radius: 12px;
            background: rgba(255,255,255,0.1); border: 2px solid #555;
            color: #ccc; cursor: pointer; transition: 0.2s; text-align: left;
            display: flex; align-items: center; gap: 15px;
        }
        .diff-btn:active { transform: scale(0.95); background: var(--accent); color: #fff; border-color: #fff; }
        .diff-icon { font-size: 1.8rem; }
        .diff-info { display: flex; flex-direction: column; }
        .diff-name { font-size: 1.1rem; font-weight: bold; color: #fff; }
        .diff-desc { font-size: 0.8rem; margin-top: 3px; }

        /* ç»“ç®— */
        #modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
        }
        .btn-restart {
            background: var(--accent); border: none; padding: 15px 40px;
            color: white; font-size: 1.2rem; border-radius: 30px; margin-top: 20px;
        }

        /* é£˜å­— */
        .floating-text {
            position: absolute; font-weight: bold; pointer-events: none;
            text-shadow: 1px 1px 0 #000; animation: floatUp 1s forwards; white-space: nowrap;
        }
        @keyframes floatUp { 
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div class="stat-box" style="border-color: #ff6b6b;">â¤ï¸ <span id="hp-val">100</span></div>
            <div class="stat-box" style="border-color: var(--accent);">
                ğŸ”® <span id="army-val">0</span> / <span id="cap-val" style="color:var(--item-rare)">3</span>
            </div>
            <div class="stat-box">ğŸ’€ <span id="score-val">0</span></div>
        </div>

        <div class="controls">
            <div id="joystick-zone">
                <div id="stick-bg"></div>
                <div id="stick"></div>
            </div>

            <div class="btn-group">
                <button class="action-btn" id="btn-cmd" onclick="Game.toggleCommand()">
                    <span id="cmd-icon">ğŸ›¡ï¸</span>
                    <span class="btn-label" id="cmd-text">è·Ÿéš</span>
                </button>
                <button class="action-btn" id="btn-tame">
                    âœ¨
                    <span class="btn-label">è½¬åŒ–</span>
                </button>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="title">ğŸ”® äº¡çµä¸»å®°</div>
        
        <div class="diff-btn" onclick="Game.start('easy')">
            <div class="diff-icon">ğŸ‘¶</div>
            <div class="diff-info">
                <div class="diff-name">è§ä¹ å·«å¸ˆ</div>
                <div class="diff-desc">æ€ªå°‘ | ä»‡æ¨ä½</div>
            </div>
        </div>
        
        <div class="diff-btn" onclick="Game.start('normal')">
            <div class="diff-icon">ğŸ§™â€â™‚ï¸</div>
            <div class="diff-info">
                <div class="diff-name">äº¡çµæ³•å¸ˆ</div>
                <div class="diff-desc">æ­£å¸¸ | ä¼˜å…ˆæ”»å‡»ç©å®¶</div>
            </div>
        </div>
        
        <div class="diff-btn" onclick="Game.start('hard')">
            <div class="diff-icon">â˜ ï¸</div>
            <div class="diff-info">
                <div class="diff-name">å·«å¦–ç‹</div>
                <div class="diff-desc">å°¸æ½® | æé«˜ä»‡æ¨</div>
            </div>
        </div>
    </div>

    <div id="modal">
        <h1 style="color: var(--accent); margin-bottom: 10px;">âš°ï¸ çµé­‚æ¶ˆæ•£</h1>
        <p style="color: #ccc;">æœ€ç»ˆæ§åˆ¶ä¸Šé™: <span id="end-cap" style="color:#fff; font-weight:bold;">0</span></p>
        <p style="color: #ccc;">å¾—åˆ†: <span id="end-score" style="color:#fff; font-weight:bold;">0</span></p>
        <button class="btn-restart" onclick="location.reload()">å†æ¬¡é‡ç”Ÿ</button>
    </div>

    <script>
        // --- ğŸ”Š éŸ³æ•ˆç³»ç»Ÿ (Web Audio API) ---
        const AudioSys = {
            ctx: null,
            init() { if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol=0.1) {
                if(!this.ctx) return;
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            // ä¿®å¤ï¼šè½¬åŒ–æ—¶çš„æŒç»­å—¡å—¡å£°
            playBeam() {
                this.playTone(100 + Math.random() * 50, 'sawtooth', 0.15, 0.05);
            },
            // è½¬åŒ–æˆåŠŸ
            playTame() { 
                this.playTone(600, 'sine', 0.1, 0.2); 
                setTimeout(()=>this.playTone(1200, 'sine', 0.3, 0.2), 100); 
            },
            playItem(type) {
                if(type === 'CAP') { 
                    this.playTone(400, 'square', 0.1, 0.1);
                    setTimeout(()=>this.playTone(800, 'square', 0.2, 0.1), 100);
                } else { 
                    this.playTone(500, 'triangle', 0.2, 0.1);
                }
            }
        };

        // --- ğŸ› ï¸ æ¸¸æˆå¼•æ“ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let WIDTH, HEIGHT;

        const Game = {
            state: 'menu',
            player: null,
            entities: [],
            items: [],
            particles: [],
            score: 0,
            camX: 0, camY: 0,
            command: 'FOLLOW',
            isTaming: false,
            tameTarget: null,
            
            // éš¾åº¦å‚æ•°
            difficulty: 'normal',
            currentCap: 3,
            hardCap: 10,
            spawnRate: 60, // åˆå§‹åˆ·æ–°é—´éš” (å¸§)
            waveTimer: 0,

            start(diff) {
                AudioSys.init();
                this.difficulty = diff;
                this.state = 'playing';
                document.getElementById('start-screen').style.display = 'none';
                
                // éš¾åº¦é…ç½®
                let startHp = 100;
                if (diff === 'easy') { 
                    this.currentCap = 5; startHp = 100; this.spawnRate = 80; 
                } else if (diff === 'normal') { 
                    this.currentCap = 3; startHp = 60; this.spawnRate = 50; 
                } else if (diff === 'hard') { 
                    this.currentCap = 2; startHp = 30; this.spawnRate = 30; 
                }

                this.player = new Player(0, 0, startHp);
                this.entities = [];
                this.items = [];
                this.particles = [];
                this.score = 0;
                this.waveTimer = 0;
                this.updateUI();
                
                this.loop();
            },

            resize() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                canvas.width = WIDTH;
                canvas.height = HEIGHT;
            },

            loop() {
                if(this.state !== 'playing') return;

                // 1. ç”Ÿæˆé€»è¾‘ (ä¼˜åŒ–ç‰ˆ)
                this.waveTimer++;
                // éš¾åº¦éšæ—¶é—´å¢åŠ ï¼šæ¯ 600å¸§(10ç§’) åˆ·æ–°åŠ å¿«ï¼Œæ€ªä¸Šé™å¢åŠ 
                const timeFactor = Math.floor(this.waveTimer / 600); 
                let currentRate = Math.max(15, this.spawnRate - timeFactor * 2); // æé™æ¯15å¸§åˆ·ä¸€åª
                
                const wildCount = this.entities.filter(e => e.team === 'wild').length;
                let maxWild = 10 + timeFactor * 2; // åˆå§‹10åªï¼Œæ— é™å¢é•¿
                if (this.difficulty === 'hard') maxWild += 10; // å›°éš¾æ¨¡å¼æ€ªæ›´å¤š

                if (this.waveTimer % currentRate === 0 && wildCount < maxWild) {
                    this.spawnEnemy();
                }

                // 2. å®ä½“æ›´æ–°
                this.player.update();
                
                // ç›¸æœºè·Ÿéš (ç¨å¾®æ»åä¸€ç‚¹ï¼Œæ›´æœ‰æ‰‹æ„Ÿ)
                this.camX += (this.player.x - WIDTH/2 - this.camX) * 0.1;
                this.camY += (this.player.y - HEIGHT/2 - this.camY) * 0.1;

                this.entities.forEach(e => e.update());
                this.items.forEach(i => i.update());
                this.particles.forEach(p => p.update());

                this.entities.sort((a, b) => a.y - b.y);

                // 3. æ¸…ç†
                this.entities = this.entities.filter(e => !e.dead);
                this.items = this.items.filter(i => !i.collected);
                this.particles = this.particles.filter(p => p.life > 0);

                // 4. ç»˜åˆ¶
                this.draw();

                // 5. è½¬åŒ–é€»è¾‘
                if (this.isTaming) this.handleTaming();
                else this.tameTarget = null;

                requestAnimationFrame(() => this.loop());
            },

            draw() {
                ctx.fillStyle = '#200f21';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                
                ctx.save();
                ctx.translate(-this.camX, -this.camY);
                
                // ç½‘æ ¼
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                const gridSize = 100;
                const startX = Math.floor(this.camX/gridSize)*gridSize;
                const startY = Math.floor(this.camY/gridSize)*gridSize;
                for(let x = startX; x < startX + WIDTH + gridSize; x+=gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY+HEIGHT+gridSize); ctx.stroke();
                }
                for(let y = startY; y < startY + HEIGHT + gridSize; y+=gridSize) {
                    ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX+WIDTH+gridSize, y); ctx.stroke();
                }

                // è½¬åŒ–å…‰æŸ
                if (this.isTaming && this.tameTarget && !this.tameTarget.dead) {
                    ctx.beginPath();
                    ctx.moveTo(this.player.x, this.player.y);
                    ctx.lineTo(this.tameTarget.x, this.tameTarget.y);
                    ctx.strokeStyle = '#b98eff';
                    ctx.lineWidth = 3 + Math.random()*4;
                    ctx.stroke();
                }

                this.items.forEach(i => i.draw());
                this.entities.forEach(e => e.draw());
                this.player.draw();
                this.particles.forEach(p => p.draw());

                ctx.restore();
            },

            spawnEnemy() {
                const angle = Math.random() * Math.PI * 2;
                // æ•Œäººç”Ÿæˆåœ¨è§†é‡å¤–
                const dist = Math.max(WIDTH, HEIGHT) * 0.6 + Math.random() * 300;
                const x = this.player.x + Math.cos(angle) * dist;
                const y = this.player.y + Math.sin(angle) * dist;
                
                const r = Math.random();
                let type = 'NORMAL';
                if (r < 0.2) type = 'TANK'; // å¦å…‹å‡ ç‡å¢åŠ 
                else if (r < 0.4) type = 'SPEED';
                else if (r < 0.5) type = 'BOOM';

                this.entities.push(new Zombie(x, y, 'wild', type));
            },

            spawnItem(x, y) {
                const r = Math.random();
                // æ‰è½ç‡è°ƒæ•´
                let capChance = 0.08 * (1 - (this.currentCap / this.hardCap)); 
                if(this.difficulty === 'hard') capChance *= 1.5; // å›°éš¾æ¨¡å¼æ‰è½ç¨å¾®é«˜ä¸€ç‚¹ç‚¹ï¼Œå› ä¸ºæ€ªå¤š

                if (r < capChance) this.items.push(new Item(x, y, 'CAP'));
                else if (r < 0.3) this.items.push(new Item(x, y, 'HEAL'));
            },

            toggleCommand() {
                this.command = this.command === 'FOLLOW' ? 'ATTACK' : 'FOLLOW';
                const btn = document.getElementById('btn-cmd');
                const icon = document.getElementById('cmd-icon');
                const text = document.getElementById('cmd-text');
                
                if (this.command === 'ATTACK') {
                    icon.innerText = 'âš”ï¸'; text.innerText = 'è‡ªç”±çŒæ€';
                    btn.style.borderColor = '#ff4757'; btn.style.color = '#ff4757';
                } else {
                    icon.innerText = 'ğŸ›¡ï¸'; text.innerText = 'æŠ¤å«ä¸»äºº';
                    btn.style.borderColor = '#0be881'; btn.style.color = '#0be881';
                }
            },

            handleTaming() {
                if (!this.tameTarget || this.tameTarget.dead || this.tameTarget.team === 'minion') {
                    let closest = null;
                    let minDist = 300;
                    this.entities.forEach(e => {
                        if (e.team === 'wild') {
                            const d = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                            if (d < minDist) { minDist = d; closest = e; }
                        }
                    });
                    this.tameTarget = closest;
                }

                if (this.tameTarget) {
                    // éŸ³æ•ˆåé¦ˆ (æ¯10å¸§æ’­æ”¾ä¸€æ¬¡ï¼Œé¿å…è¿‡äºåˆºè€³)
                    if (this.waveTimer % 10 === 0) AudioSys.playBeam();

                    const dist = Math.hypot(this.tameTarget.x - this.player.x, this.tameTarget.y - this.player.y);
                    if (dist > 320) { this.tameTarget = null; return; }

                    let rate = 1.5;
                    if (this.tameTarget.type === 'TANK') rate = 0.8;
                    
                    this.tameTarget.tameProgress += rate;
                    this.tameTarget.speed *= 0.2; 

                    if (this.tameTarget.tameProgress >= 100) {
                        this.convertZombie(this.tameTarget);
                        this.tameTarget = null;
                    }
                }
            },

            convertZombie(target) {
                const currentMinions = this.entities.filter(e => e.team === 'minion').length;
                if (currentMinions >= this.currentCap) {
                    showText(this.player.x, this.player.y - 30, "ä¸Šé™å·²æ»¡!", '#f00');
                    target.takeDamage(999); 
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + 15); 
                    this.updateUI();
                    return;
                }

                target.team = 'minion';
                target.hp = target.maxHp;
                target.tameProgress = 0;
                AudioSys.playTame();
                createParticles(target.x, target.y, '#0be881', 15);
                showText(target.x, target.y - 20, "æ•è·!", '#0be881');
                this.updateUI();
            },

            updateUI() {
                document.getElementById('hp-val').innerText = Math.floor(this.player.hp);
                const count = this.entities.filter(e => e.team === 'minion').length;
                document.getElementById('army-val').innerText = count;
                document.getElementById('cap-val').innerText = this.currentCap;
                document.getElementById('score-val').innerText = this.score;
            },

            gameOver() {
                this.state = 'over';
                document.getElementById('end-cap').innerText = this.currentCap;
                document.getElementById('end-score').innerText = this.score;
                document.getElementById('modal').style.display = 'flex';
            }
        };

        // --- ğŸ é“å…· ---
        class Item {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.collected = false; this.bobOffset = Math.random() * Math.PI;
            }
            update() {
                this.bobOffset += 0.1;
                const dist = Math.hypot(this.x - Game.player.x, this.y - Game.player.y);
                if (dist < 30) this.collect();
            }
            collect() {
                this.collected = true;
                AudioSys.playItem(this.type);
                if (this.type === 'HEAL') {
                    Game.player.hp = Math.min(Game.player.maxHp, Game.player.hp + 30);
                    showText(Game.player.x, Game.player.y - 30, "+HP", '#ff6b6b');
                } else if (this.type === 'CAP') {
                    if (Game.currentCap < Game.hardCap) {
                        Game.currentCap++;
                        showText(Game.player.x, Game.player.y - 50, "ä¸Šé™çªç ´!", '#00d2d3');
                    } else {
                        Game.score += 500;
                        showText(Game.player.x, Game.player.y - 50, "é­”åŠ›æº¢å‡º!", '#00d2d3');
                    }
                }
                Game.updateUI();
            }
            draw() {
                const y = this.y + Math.sin(this.bobOffset) * 5;
                ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (this.type === 'CAP') {
                    ctx.fillText('ğŸ’', this.x, y);
                    ctx.strokeStyle = 'rgba(0, 210, 211, 0.5)';
                    ctx.beginPath(); ctx.arc(this.x, y, 15, 0, Math.PI*2); ctx.stroke();
                } else { ctx.fillText('ğŸ¥©', this.x, y); }
            }
        }

        // --- ğŸ­ å®ä½“ ---
        class Entity {
            constructor(x, y, r, color) {
                this.x = x; this.y = y; this.r = r; this.color = color;
                this.dead = false;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
            }
        }

        class Player extends Entity {
            constructor(x, y, maxHp) {
                super(x, y, 15, '#b98eff');
                this.speed = 4; this.maxHp = maxHp; this.hp = maxHp;
            }
            update() {
                if (joystick.active) {
                    this.x += joystick.x * this.speed; this.y += joystick.y * this.speed;
                }
            }
            takeDamage(amt) {
                this.hp -= amt; Game.updateUI();
                createParticles(this.x, this.y, '#fff', 3);
                if (this.hp <= 0) Game.gameOver();
            }
            draw() {
                ctx.strokeStyle = 'rgba(185, 142, 255, 0.1)';
                ctx.beginPath(); ctx.arc(this.x, this.y, 280, 0, Math.PI*2); ctx.stroke();
                super.draw();
                ctx.fillStyle = '#4a235a';
                ctx.beginPath(); ctx.moveTo(this.x-10, this.y-10); ctx.lineTo(this.x, this.y-30); ctx.lineTo(this.x+10, this.y-10); ctx.fill();
            }
        }

        class Zombie extends Entity {
            constructor(x, y, team, type='NORMAL') {
                super(x, y, 12, '#ff4757');
                this.team = team; this.type = type;
                this.tameProgress = 0; this.cd = 0;
                
                if (type === 'NORMAL') { this.hp = 30; this.speedBase = 2; this.dmg = 5; this.color = '#ff4757'; }
                else if (type === 'TANK') { this.hp = 100; this.speedBase = 1.2; this.dmg = 10; this.r = 18; this.color = '#8e44ad'; }
                else if (type === 'SPEED') { this.hp = 15; this.speedBase = 3.5; this.dmg = 3; this.r = 8; this.color = '#f1c40f'; }
                else if (type === 'BOOM') { this.hp = 20; this.speedBase = 2.5; this.dmg = 50; this.color = '#e67e22'; }
                this.maxHp = this.hp; this.speed = this.speedBase;
            }

            update() {
                this.speed = this.speedBase;
                if(this.cd > 0) this.cd--;

                let target = null;
                
                // --- æ ¸å¿ƒ AI ä¼˜åŒ–: ä¼˜å…ˆæ”»å‡»ç©å®¶ ---
                if (this.team === 'wild') {
                    // 1. è®¡ç®—è·ç¦»
                    const distToPlayer = Math.hypot(Game.player.x - this.x, Game.player.y - this.y);
                    
                    // é»˜è®¤ç›®æ ‡æ˜¯ç©å®¶
                    target = Game.player;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰éšä»æŒ¡è·¯ (è·ç¦»æè¿‘)
                    // åªæœ‰å½“éšä»éå¸¸è¿‘ (<80) æ—¶ï¼Œåƒµå°¸æ‰ä¼šè¢«è¿«æ”»å‡»éšä»ï¼Œå¦åˆ™å®ƒä»¬ä¼šè¯•å›¾ç»•è¿‡
                    let closestMinion = null;
                    let minMinionDist = 80; 
                    
                    Game.entities.forEach(e => {
                        if (e.team === 'minion') {
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d < minMinionDist) {
                                minMinionDist = d;
                                closestMinion = e;
                            }
                        }
                    });

                    if (closestMinion) {
                        target = closestMinion; // è¢«æŒ¡è·¯äº†ï¼Œåªèƒ½å…ˆæ‰“éšä»
                    }
                    
                } else {
                    // éšä»é€»è¾‘
                    if (Game.command === 'FOLLOW') {
                        const distPlayer = Math.hypot(Game.player.x - this.x, Game.player.y - this.y);
                        if (distPlayer > 80) { target = Game.player; } 
                        else {
                            // æŠ¤å«åŠå¾„
                            let minDist = 150;
                            Game.entities.filter(e => e.team === 'wild').forEach(e => {
                                const d = Math.hypot(e.x - this.x, e.y - this.y);
                                if (d < minDist) { minDist = d; target = e; }
                            });
                        }
                    } else {
                        let minDist = 600;
                        Game.entities.filter(e => e.team === 'wild').forEach(e => {
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d < minDist) { minDist = d; target = e; }
                        });
                    }
                }

                if (target) {
                    const dx = target.x - this.x; const dy = target.y - this.y;
                    const d = Math.hypot(dx, dy);
                    
                    // é˜²é‡å 
                    Game.entities.forEach(e => {
                        if (e !== this && !e.dead) {
                            const dd = Math.hypot(e.x - this.x, e.y - this.y);
                            if (dd < this.r + e.r) {
                                this.x -= (e.x - this.x) * 0.05;
                                this.y -= (e.y - this.y) * 0.05;
                            }
                        }
                    });

                    if (d > this.r + target.r + 2) {
                        this.x += (dx/d) * this.speed; this.y += (dy/d) * this.speed;
                    } else {
                        if (this.type === 'BOOM' && ((this.team === 'wild' && target === Game.player) || (this.team === 'minion' && target.team === 'wild'))) {
                            this.explode();
                        } else if (this.cd <= 0 && target.takeDamage) {
                            target.takeDamage(this.dmg); this.cd = 30;
                        }
                    }
                }
            }

            takeDamage(amt) {
                this.hp -= amt; createParticles(this.x, this.y, this.color, 2);
                if (this.hp <= 0) {
                    this.dead = true;
                    if (this.team === 'wild') {
                        Game.score += 10; Game.spawnItem(this.x, this.y); Game.updateUI();
                    }
                }
            }

            explode() {
                this.dead = true; createParticles(this.x, this.y, '#e67e22', 20);
                const range = 100;
                [...Game.entities, Game.player].forEach(e => {
                    if (e.dead) return;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < range) {
                        if (e.team !== this.team) e.takeDamage(this.dmg);
                        else e.takeDamage(this.dmg * 0.2);
                    }
                });
            }

            draw() {
                ctx.fillStyle = this.team === 'minion' ? '#0be881' : this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'red'; ctx.fillRect(this.x-10, this.y-this.r-6, 20, 3);
                ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-10, this.y-this.r-6, 20 * (this.hp/this.maxHp), 3);
                if (this.team === 'wild' && this.tameProgress > 0) {
                    ctx.fillStyle = '#b98eff'; ctx.fillRect(this.x-10, this.y-this.r-10, 20 * (this.tameProgress/100), 3);
                }
                ctx.fillStyle = '#fff'; ctx.font = '10px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                let icon = ''; if(this.type==='TANK') icon='ğŸ›¡ï¸'; else if(this.type==='SPEED') icon='âš¡'; else if(this.type==='BOOM') icon='ğŸ’£';
                if(icon) ctx.fillText(icon, this.x, this.y);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random()-0.5)*4; this.vy = (Math.random()-0.5)*4; this.life = 20;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life--; }
            draw() { ctx.fillStyle=this.color; ctx.globalAlpha=this.life/20; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha=1; }
        }

        // --- äº¤äº’ ---
        const tameBtn = document.getElementById('btn-tame');
        const startTame = (e) => { e.preventDefault(); Game.isTaming = true; tameBtn.classList.add('active'); };
        const endTame = (e) => { e.preventDefault(); Game.isTaming = false; tameBtn.classList.remove('active'); };
        tameBtn.addEventListener('touchstart', startTame); tameBtn.addEventListener('touchend', endTame);
        tameBtn.addEventListener('mousedown', startTame); tameBtn.addEventListener('mouseup', endTame);

        const stick = document.getElementById('stick');
        const zone = document.getElementById('joystick-zone');
        const joystick = { x: 0, y: 0, active: false, originX: 0, originY: 0 };

        zone.addEventListener('touchstart', e => {
            e.preventDefault(); joystick.active = true;
            const t = e.touches[0]; const r = zone.getBoundingClientRect();
            joystick.originX = r.left + r.width/2; joystick.originY = r.top + r.height/2;
            updateStick(t.clientX, t.clientY);
        }, {passive:false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault(); if(joystick.active) updateStick(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive:false});

        const resetStick = () => { joystick.active = false; joystick.x=0; joystick.y=0; stick.style.left='55px'; stick.style.top='55px'; };
        zone.addEventListener('touchend', resetStick); zone.addEventListener('touchcancel', resetStick);

        function updateStick(cx, cy) {
            const max = 50;
            let dx = cx - joystick.originX, dy = cy - joystick.originY;
            const d = Math.hypot(dx, dy);
            if(d > max) { dx *= max/d; dy *= max/d; }
            stick.style.left = (55+dx)+'px'; stick.style.top = (55+dy)+'px';
            joystick.x = dx/max; joystick.y = dy/max;
        }

        function createParticles(x, y, c, n) { for(let i=0; i<n; i++) Game.particles.push(new Particle(x, y, c)); }
        function showText(x, y, txt, c) {
            const el = document.createElement('div'); el.className = 'floating-text';
            el.innerText = txt; el.style.color = c;
            const sx = WIDTH/2 + (x - Game.player.x); const sy = HEIGHT/2 + (y - Game.player.y);
            el.style.left = sx + 'px'; el.style.top = sy + 'px';
            document.body.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
        }

        window.addEventListener('resize', () => Game.resize());
        Game.resize();

    </script>
</body>
</html>