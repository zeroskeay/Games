<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°¸æ§ï¼šæœ«æ—¥å‚€å„¡å¸ˆ</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --ui-bg: rgba(0, 0, 0, 0.6);
            --accent: #baffc9; /* å¹½çµç»¿ */
            --danger: #ff6b6b;
            --minion: #4dabf7;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */
            user-select: none;
            -webkit-user-select: none;
        }

        canvas { display: block; }

        /* --- UI å±‚ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        .status-bar {
            background: var(--ui-bg);
            padding: 10px;
            display: flex; gap: 15px;
            color: white; font-size: 0.9rem; font-weight: bold;
            backdrop-filter: blur(4px);
            border-bottom: 1px solid #333;
        }
        .res-item { display: flex; align-items: center; gap: 5px; }
        .icon { font-size: 1.2rem; }

        /* è½¬åŒ–è¿›åº¦æ¡ (åœ¨è§’è‰²å¤´é¡¶ï¼Œä½†è¿™é‡Œç”¨DOMæ–¹ä¾¿åšUI) */
        #convert-bar-container {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            width: 120px; height: 10px; background: #333; border-radius: 5px;
            display: none; border: 1px solid white;
        }
        #convert-bar-fill {
            width: 0%; height: 100%; background: var(--accent); border-radius: 5px;
            transition: width 0.1s linear;
        }

        /* åº•éƒ¨æ§åˆ¶åŒº */
        .controls {
            display: flex; justify-content: space-between; align-items: flex-end;
            padding: 20px;
            pointer-events: auto; /* å…è®¸ç‚¹å‡» */
        }

        /* è™šæ‹Ÿæ‘‡æ†åŒºåŸŸ (å·¦ä¾§éšå½¢) */
        #joystick-zone {
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
        }
        #stick {
            width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%;
            transform: translate(0, 0);
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        /* å³ä¾§æŠ€èƒ½æŒ‰é’® */
        .action-grid {
            display: flex; flex-direction: column; gap: 15px;
            margin-left: auto; margin-bottom: 10px;
        }
        
        .btn {
            width: 65px; height: 65px; border-radius: 50%; border: none;
            background: var(--ui-bg); color: white; font-size: 1.5rem;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        
        .btn-main { width: 80px; height: 80px; background: rgba(186, 255, 201, 0.2); border: 2px solid var(--accent); }
        .btn-main.active { background: var(--accent); color: black; }

        .btn-label {
            position: absolute; bottom: -18px; font-size: 0.7rem; width: 100%; text-align: center;
            text-shadow: 1px 1px 0 #000;
        }

        /* äº¤äº’æç¤º */
        #message {
            position: absolute; top: 100px; width: 100%; text-align: center;
            color: var(--accent); font-weight: bold; font-size: 1.2rem;
            text-shadow: 0 2px 4px black; opacity: 0; transition: opacity 0.5s;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="status-bar">
            <div class="res-item">â¤ï¸ <span id="hp-val">100</span></div>
            <div class="res-item">ğŸ§¬ <span id="bio-val">0</span></div>
            <div class="res-item">ğŸ§Ÿ <span id="minion-val">0/5</span></div>
        </div>

        <div id="convert-bar-container">
            <div id="convert-bar-fill"></div>
        </div>

        <div id="message"></div>

        <div class="controls">
            <div id="joystick-zone">
                <div id="stick"></div>
            </div>

            <div class="action-grid">
                <button class="btn" id="mode-btn" ontouchstart="toggleMode(event)">
                    ğŸ›¡ï¸
                    <span class="btn-label">é˜²å¾¡/è¿›æ”»</span>
                </button>
                <button class="btn btn-main" id="action-btn">
                    âš¡
                    <span class="btn-label">è½¬åŒ–</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            playerSpeed: 3,
            zombieSpeed: 1.5,
            minionSpeed: 2.5,
            convertTime: 60, // å¸§æ•° (çº¦1ç§’)
            spawnRate: 180, // 3ç§’ç”Ÿæˆä¸€åª
            maxMinions: 5
        };

        // --- æ¸¸æˆçŠ¶æ€ ---
        const state = {
            hp: 100,
            biomass: 0,
            mode: 'DEFEND', // DEFEND (è·Ÿéš), ATTACK (ä¸»åŠ¨ç´¢æ•Œ)
            converting: null, // å½“å‰æ­£åœ¨è½¬åŒ–çš„ç›®æ ‡
            convertProgress: 0,
            wave: 1
        };

        // --- å®ä½“ç³»ç»Ÿ ---
        const entities = {
            player: null,
            zombies: [],
            minions: [],
            particles: []
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let WIDTH, HEIGHT;

        // --- åˆå§‹åŒ– ---
        function resize() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ç±»å®šä¹‰ ---
        class Entity {
            constructor(x, y, r, color) {
                this.x = x; this.y = y; this.r = r; this.color = color;
                this.dead = false;
                this.hp = 10;
                this.maxHp = 10;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
                // è¡€æ¡
                if(this.hp < this.maxHp) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - 10, this.y - this.r - 8, 20, 4);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(this.x - 10, this.y - this.r - 8, 20 * (this.hp/this.maxHp), 4);
                }
            }
            distanceTo(other) {
                return Math.hypot(this.x - other.x, this.y - other.y);
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 15, '#fff'); // ç™½è‰²ä¸»è§’
                this.hp = 100;
                this.maxHp = 100;
            }
            update(dx, dy) {
                this.x += dx * config.playerSpeed;
                this.y += dy * config.playerSpeed;
                // è¾¹ç•Œé™åˆ¶
                this.x = Math.max(15, Math.min(WIDTH-15, this.x));
                this.y = Math.max(15, Math.min(HEIGHT-15, this.y));
            }
            draw() {
                super.draw();
                // èŒƒå›´åœˆ
                ctx.beginPath();
                ctx.arc(this.x, this.y, 100, 0, Math.PI*2); // è½¬åŒ–èŒƒå›´
                ctx.strokeStyle = 'rgba(186, 255, 201, 0.1)';
                ctx.stroke();
            }
        }

        class Zombie extends Entity {
            constructor(x, y, type = 'basic') {
                super(x, y, 12, '#ff6b6b'); // çº¢è‰²åƒµå°¸
                this.type = type;
                if(type === 'tank') {
                    this.r = 20; this.hp = 30; this.maxHp = 30; this.color = '#800';
                }
            }
            update() {
                // ç®€å•çš„AIï¼šå¦‚æœæœ‰å‚€å„¡è¿½å‚€å„¡ï¼Œå¦åˆ™è¿½ç©å®¶
                let target = entities.player;
                let minDist = this.distanceTo(entities.player);
                
                // å¯»æ‰¾æœ€è¿‘çš„å‚€å„¡
                entities.minions.forEach(m => {
                    const d = this.distanceTo(m);
                    if (d < minDist && d < 200) { // 200èŒƒå›´å†…æ‰è¢«å¸å¼•
                        minDist = d;
                        target = m;
                    }
                });

                if (minDist > this.r + target.r) {
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const spd = this.type === 'tank' ? config.zombieSpeed * 0.6 : config.zombieSpeed;
                    this.x += Math.cos(angle) * spd;
                    this.y += Math.sin(angle) * spd;
                } else {
                    // æ”»å‡»
                    if(Math.random() < 0.05) { // æ”»å‡»é¢‘ç‡
                        target.hp -= 1;
                        createParticles(target.x, target.y, 'red', 3);
                        if(target === entities.player) updateUI();
                    }
                }
            }
        }

        class Minion extends Entity {
            constructor(x, y, type) {
                super(x, y, 12, '#4dabf7'); // è“è‰²å‚€å„¡
                this.type = type;
                if(type === 'tank') {
                    this.r = 20; this.hp = 40; this.maxHp = 40; this.color = '#154c79';
                }
            }
            update() {
                // AI é€»è¾‘
                let target = null;
                
                if (state.mode === 'ATTACK') {
                    // æ‰¾æœ€è¿‘çš„åƒµå°¸
                    let minDist = 9999;
                    entities.zombies.forEach(z => {
                        const d = this.distanceTo(z);
                        if (d < minDist) { minDist = d; target = z; }
                    });
                } else {
                    // é˜²å¾¡æ¨¡å¼ï¼šå›åˆ°ç©å®¶èº«è¾¹ï¼Œé™¤ééå¸¸è¿‘æœ‰åƒµå°¸
                    const distToPlayer = this.distanceTo(entities.player);
                    if (distToPlayer > 60) {
                         target = entities.player;
                    } else {
                        // åœ¨ç©å®¶èº«è¾¹å·¡é€»ï¼Œæ‰¾é™„è¿‘çš„åƒµå°¸
                        entities.zombies.forEach(z => {
                             if(this.distanceTo(z) < 100) target = z;
                        });
                    }
                }

                if (target) {
                    const dist = this.distanceTo(target);
                    if (dist > this.r + target.r + 5) {
                        const angle = Math.atan2(target.y - this.y, target.x - this.x);
                        this.x += Math.cos(angle) * config.minionSpeed;
                        this.y += Math.sin(angle) * config.minionSpeed;
                    } else if (target instanceof Zombie) {
                        // æ”»å‡»åƒµå°¸
                        if(Math.random() < 0.1) {
                            target.hp -= (this.type === 'tank' ? 3 : 1);
                            createParticles(target.x, target.y, '#baffc9', 2);
                        }
                    }
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ç³»ç»Ÿé€»è¾‘ ---
        function init() {
            entities.player = new Player(WIDTH/2, HEIGHT/2);
            entities.zombies = [];
            entities.minions = [];
            state.biomass = 0;
            updateUI();
            loop();
        }

        function spawnZombie() {
            // éšæœºè¾¹ç¼˜ç”Ÿæˆ
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -20 : WIDTH + 20;
                y = Math.random() * HEIGHT;
            } else {
                x = Math.random() * WIDTH;
                y = Math.random() < 0.5 ? -20 : HEIGHT + 20;
            }
            
            // 10% æ¦‚ç‡ç”Ÿæˆå¦å…‹åƒµå°¸
            const type = Math.random() < 0.1 ? 'tank' : 'basic';
            entities.zombies.push(new Zombie(x, y, type));
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) entities.particles.push(new Particle(x, y, color));
        }

        // --- ä¸»å¾ªç¯ ---
        let frames = 0;
        function loop() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // ç½‘æ ¼èƒŒæ™¯çº¿
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<WIDTH; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,HEIGHT); }
            for(let i=0; i<HEIGHT; i+=50) { ctx.moveTo(0,i); ctx.lineTo(WIDTH,i); }
            ctx.stroke();

            frames++;
            if (frames % config.spawnRate === 0) spawnZombie();

            // 1. æ‘‡æ†æ§åˆ¶ç§»åŠ¨
            if (joystick.active) {
                entities.player.update(joystick.x, joystick.y);
                // ç§»åŠ¨æ—¶æ‰“æ–­è½¬åŒ–
                if (state.converting) stopConvert();
            }

            // 2. è½¬åŒ–é€»è¾‘ (Channeling)
            if (state.converting) {
                const dist = entities.player.distanceTo(state.converting);
                if (dist > 120 || state.converting.dead) {
                    stopConvert();
                } else {
                    state.convertProgress++;
                    // æ›´æ–°UI
                    const bar = document.getElementById('convert-bar-fill');
                    const pct = (state.convertProgress / config.convertTime) * 100;
                    bar.style.width = pct + '%';
                    
                    // è¿æ¥çº¿
                    ctx.beginPath();
                    ctx.moveTo(entities.player.x, entities.player.y);
                    ctx.lineTo(state.converting.x, state.converting.y);
                    ctx.strokeStyle = `rgba(186, 255, 201, ${Math.random()})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // å®Œæˆè½¬åŒ–
                    if (state.convertProgress >= config.convertTime) {
                        successConvert(state.converting);
                    }
                }
            }

            // 3. æ›´æ–°å®ä½“
            entities.player.draw();

            entities.zombies.forEach(z => {
                z.update();
                z.draw();
                if (z.hp <= 0) {
                    z.dead = true;
                    state.biomass += 5;
                    updateUI();
                    createParticles(z.x, z.y, '#3f3', 10);
                }
            });

            entities.minions.forEach(m => {
                m.update();
                m.draw();
                if (m.hp <= 0) m.dead = true;
            });

            entities.particles.forEach(p => { p.update(); p.draw(); });

            // æ¸…ç†
            entities.zombies = entities.zombies.filter(z => !z.dead);
            entities.minions = entities.minions.filter(m => !m.dead);
            entities.particles = entities.particles.filter(p => p.life > 0);

            // å¤±è´¥åˆ¤å®š
            if (entities.player.hp <= 0) {
                alert("ä½ è¢«åå™¬äº†... åˆ·æ–°é‡æ¥");
                location.reload();
                return;
            }

            requestAnimationFrame(loop);
        }

        // --- äº¤äº’é€»è¾‘ ---
        function startConvert() {
            if (entities.minions.length >= config.maxMinions) {
                showMessage("å‚€å„¡å·²è¾¾ä¸Šé™!");
                return;
            }

            // å¯»æ‰¾æœ€è¿‘çš„åƒµå°¸
            let target = null;
            let minDist = 120; // è½¬åŒ–è·ç¦»

            entities.zombies.forEach(z => {
                const d = entities.player.distanceTo(z);
                if (d < minDist) {
                    minDist = d;
                    target = z;
                }
            });

            if (target) {
                state.converting = target;
                state.convertProgress = 0;
                document.getElementById('convert-bar-container').style.display = 'block';
                // éœ‡åŠ¨åé¦ˆ
                if(navigator.vibrate) navigator.vibrate(50);
            } else {
                showMessage("è·ç¦»ç›®æ ‡å¤ªè¿œ");
            }
        }

        function stopConvert() {
            state.converting = null;
            state.convertProgress = 0;
            document.getElementById('convert-bar-container').style.display = 'none';
            document.getElementById('convert-bar-fill').style.width = '0%';
        }

        function successConvert(zombie) {
            // ç§»é™¤åƒµå°¸ï¼Œç”Ÿæˆå‚€å„¡
            zombie.dead = true;
            entities.minions.push(new Minion(zombie.x, zombie.y, zombie.type));
            
            createParticles(zombie.x, zombie.y, '#4dabf7', 20);
            showMessage("è½¬åŒ–æˆåŠŸ!");
            stopConvert();
            updateUI();
        }

        function toggleMode(e) {
            if(e) e.preventDefault(); // é˜²æ­¢è§¦æ‘¸ç©¿é€
            state.mode = state.mode === 'DEFEND' ? 'ATTACK' : 'DEFEND';
            
            const btn = document.getElementById('mode-btn');
            if (state.mode === 'ATTACK') {
                btn.innerHTML = 'âš”ï¸<span class="btn-label">å…¨å†›çªå‡»</span>';
                btn.style.background = '#ff6b6b';
                showMessage("å…¨å†›çªå‡»!");
            } else {
                btn.innerHTML = 'ğŸ›¡ï¸<span class="btn-label">è·ŸéšæŠ¤å«</span>';
                btn.style.background = 'var(--ui-bg)';
                showMessage("å¬å›æŠ¤å«");
            }
        }

        function updateUI() {
            document.getElementById('hp-val').innerText = entities.player.hp;
            document.getElementById('bio-val').innerText = state.biomass;
            document.getElementById('minion-val').innerText = `${entities.minions.length}/${config.maxMinions}`;
        }

        function showMessage(msg) {
            const el = document.getElementById('message');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1000);
        }

        // --- æ‘‡æ†é€»è¾‘ ---
        const joystickZone = document.getElementById('joystick-zone');
        const stick = document.getElementById('stick');
        const joystick = { active: false, x: 0, y: 0, originX: 0, originY: 0 };

        joystickZone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickZone.getBoundingClientRect();
            // é‡ç½®ä¸­å¿ƒç‚¹
            joystick.originX = rect.left + rect.width/2;
            joystick.originY = rect.top + rect.height/2;
            joystick.active = true;
            updateStick(touch.clientX, touch.clientY);
        }, {passive: false});

        joystickZone.addEventListener('touchmove', e => {
            e.preventDefault();
            if (joystick.active) {
                const touch = e.touches[0];
                updateStick(touch.clientX, touch.clientY);
            }
        }, {passive: false});

        joystickZone.addEventListener('touchend', e => {
            e.preventDefault();
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            stick.style.transform = `translate(0px, 0px)`;
        });

        function updateStick(clientX, clientY) {
            const maxDist = 50; // æ‘‡æ†åŠå¾„
            let dx = clientX - joystick.originX;
            let dy = clientY - joystick.originY;
            const dist = Math.hypot(dx, dy);

            // å½’ä¸€åŒ–æ–¹å‘å‘é‡
            if (dist > maxDist) {
                const ratio = maxDist / dist;
                dx *= ratio;
                dy *= ratio;
            }

            // ç§»åŠ¨UI
            stick.style.transform = `translate(${dx}px, ${dy}px)`;

            // è¾“å‡ºå½’ä¸€åŒ–é€Ÿåº¦ (-1 åˆ° 1)
            joystick.x = dx / maxDist;
            joystick.y = dy / maxDist;
        }

        // è½¬åŒ–æŒ‰é’®é€»è¾‘ (æ”¯æŒé•¿æŒ‰)
        const actionBtn = document.getElementById('action-btn');
        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            actionBtn.classList.add('active');
            startConvert();
        });
        actionBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            actionBtn.classList.remove('active');
            stopConvert();
        });

        // PCç«¯é¼ æ ‡æ”¯æŒ (æµ‹è¯•ç”¨)
        let mouseX, mouseY;
        canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('keydown', e => {
            if(e.code === 'Space') startConvert();
            if(e.key === 'f') toggleMode();
        });
        window.addEventListener('keyup', e => {
            if(e.code === 'Space') stopConvert();
        });

        // å¯åŠ¨
        init();

    </script>
</body>
</html>