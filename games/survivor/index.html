<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åƒµå°¸æ”¶å‰²æœºï¼šå¹¸å­˜è€…</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --accent: #e94560;
            --text: #fff;
            --xp: #0f3460;
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: 'Segoe UI', sans-serif; user-select: none;
            touch-action: none; color: var(--text);
        }

        canvas { display: block; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* é¡¶éƒ¨ HUD */
        .hud {
            padding: 15px; display: flex; justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }
        .bar-container {
            flex: 1; margin: 0 15px; height: 20px; background: #333;
            border-radius: 10px; overflow: hidden; position: relative;
            border: 2px solid #555;
        }
        #xp-bar {
            width: 0%; height: 100%; background: #4facfe;
            transition: width 0.2s;
        }
        .level-badge {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            font-size: 0.8rem; font-weight: bold; text-shadow: 1px 1px 0 #000;
        }

        /* å¯åŠ¨/éš¾åº¦é€‰æ‹© */
        #start-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; pointer-events: auto;
        }
        .title { font-size: 2.5rem; color: var(--accent); margin-bottom: 30px; text-shadow: 0 0 20px var(--accent); text-align: center;}
        .diff-btn {
            background: #16213e; color: #fff; border: 2px solid #0f3460;
            width: 200px; padding: 15px; margin: 10px; font-size: 1.2rem;
            cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: space-between; align-items: center;
        }
        .diff-btn:active { transform: scale(0.95); background: var(--accent); }
        .diff-icon { font-size: 1.5rem; }

        /* å‡çº§å¼¹çª— */
        #upgrade-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .card-container {
            display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px;
        }
        .upgrade-card {
            background: linear-gradient(45deg, #16213e, #1a1a2e);
            border: 2px solid #4facfe; border-radius: 12px;
            padding: 15px; cursor: pointer; display: flex; align-items: center; gap: 15px;
            transition: transform 0.1s;
        }
        .upgrade-card:active { transform: scale(0.98); background: #4facfe; color: #000; }
        .card-icon { font-size: 2.5rem; }
        .card-info h3 { margin: 0 0 5px 0; font-size: 1.1rem; color: #ffd700; }
        .card-info p { margin: 0; font-size: 0.85rem; color: #ccc; }

        /* è™šæ‹Ÿæ‘‡æ† */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 200px; pointer-events: auto;
        }
        #stick-bg {
            position: absolute; width: 100px; height: 100px; background: rgba(255,255,255,0.1);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;
        }
        #stick {
            position: absolute; width: 40px; height: 40px; background: var(--accent);
            border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: none; box-shadow: 0 0 10px var(--accent);
        }

        /* æ­»äº¡/é€šå…³ */
        #game-over {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 300; pointer-events: auto;
        }
        .stat-box { text-align: center; margin-bottom: 30px; line-height: 1.8; color: #ccc; }
        .big-num { font-size: 1.5rem; color: #fff; font-weight: bold; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div>â±ï¸ <span id="timer">00:00</span></div>
            <div class="bar-container">
                <div id="xp-bar"></div>
                <div class="level-badge">LV <span id="level-val">1</span></div>
            </div>
            <div>ğŸ’€ <span id="kill-val">0</span></div>
        </div>

        <div id="joystick-zone">
            <div id="stick-bg"><div id="stick"></div></div>
        </div>
    </div>

    <div id="start-screen">
        <div class="title">ğŸ§Ÿ åƒµå°¸æ”¶å‰²æœº<br><span style="font-size:1rem; color:#fff; opacity:0.7">SURVIVOR</span></div>
        <div class="diff-btn" onclick="Game.start('easy')">
            <span class="diff-icon">ğŸ‘¶</span>
            <div>
                <div>èœé¸Ÿæ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">åƒµå°¸å¾ˆæ…¢ï¼Œé€‚åˆçƒ­æ‰‹</div>
            </div>
        </div>
        <div class="diff-btn" onclick="Game.start('normal')">
            <span class="diff-icon">ğŸ’€</span>
            <div>
                <div>è€å…µæ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">æ ‡å‡†é€Ÿåº¦ï¼Œæ€ªæ½®æ±¹æ¶Œ</div>
            </div>
        </div>
        <div class="diff-btn" onclick="Game.start('hard')">
            <span class="diff-icon">ğŸ‘¹</span>
            <div>
                <div>åœ°ç‹±æ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">æå¿«é€Ÿåº¦ï¼Œç”Ÿå­˜æŒ‘æˆ˜</div>
            </div>
        </div>
    </div>

    <div id="upgrade-modal">
        <h2 style="color:#fff; margin-bottom:20px;">å‡çº§å•¦ï¼é€‰æ‹©å¥–åŠ±</h2>
        <div class="card-container" id="cards-box"></div>
    </div>

    <div id="game-over">
        <h1 id="end-title" style="color: #e94560; font-size: 3rem; margin-bottom: 10px;">ä½ æŒ‚äº†</h1>
        <div class="stat-box">
            å­˜æ´»æ—¶é—´ <div class="big-num" id="end-time">00:00</div><br>
            å‡»æ€åƒµå°¸ <div class="big-num" id="end-kills">0</div><br>
            æœ€ç»ˆç­‰çº§ <div class="big-num" id="end-level">1</div>
        </div>
        <div class="diff-btn" style="justify-content: center;" onclick="location.reload()">å†æ¥ä¸€å±€</div>
    </div>

    <script>
        // --- éŸ³æ•ˆ ---
        const AudioSys = {
            ctx: null,
            init() { if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            play(type) {
                if(!this.ctx) return;
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination);
                const now = this.ctx.currentTime;

                if(type==='shoot'){
                    osc.type = 'sine'; osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now+0.1);
                } else if(type==='hit'){
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
                    osc.start(now); osc.stop(now+0.1);
                } else if(type==='xp'){
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now);
                    osc.frequency.linearRampToValueAtTime(1200, now+0.1);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
                    osc.start(now); osc.stop(now+0.1);
                } else if(type==='levelup'){
                    [440, 554, 659].forEach((f,i)=>{
                        const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
                        o.type='square'; o.frequency.value=f; g.gain.setValueAtTime(0.1,now+i*0.1);
                        g.gain.exponentialRampToValueAtTime(0.01,now+i*0.1+0.5);
                        o.connect(g); g.connect(this.ctx.destination); o.start(now+i*0.1); o.stop(now+i*0.1+0.5);
                    });
                }
            }
        };

        // --- å¼•æ“ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let WIDTH, HEIGHT;

        const Game = {
            state: 'menu',
            frames: 0, time: 0, kills: 0, difficulty: 'normal',
            player: null, enemies: [], xpGems: [], bullets: [], texts: [],
            camera: {x:0, y:0},
            upgrades: [
                { id: 'speed', name: 'ç–¾é£æ­¥', desc: 'ç§»åŠ¨é€Ÿåº¦ +20%', icon: 'ğŸ‘Ÿ', type: 'stat', stat: 'speed', val: 1 },
                { id: 'rate', name: 'å¿«æªæ‰‹', desc: 'å°„å‡»é¢‘ç‡ +20%', icon: 'âš¡', type: 'stat', stat: 'fireRate', val: 0.8 },
                { id: 'damage', name: 'å¼ºåŠ›å¼¹', desc: 'å­å¼¹ä¼¤å®³ +5', icon: 'ğŸ’¥', type: 'stat', stat: 'damage', val: 5 },
                { id: 'multi', name: 'å¤šé‡å°„å‡»', desc: 'å­å¼¹æ•°é‡ +1', icon: 'ğŸ’', type: 'stat', stat: 'bulletCount', val: 1 },
                { id: 'aura', name: 'å¤§è’œå…‰ç¯', desc: 'è·å¾—ä¼¤å®³å…‰ç¯/èŒƒå›´å˜å¤§', icon: 'ğŸ§„', type: 'weapon', weapon: 'aura' }
            ],

            start(diff) {
                AudioSys.init();
                this.difficulty = diff;
                this.state = 'playing';
                document.getElementById('start-screen').style.display = 'none';
                
                this.player = new Player();
                this.enemies = []; this.xpGems = []; this.bullets = []; this.texts = [];
                this.frames = 0; this.time = 0; this.kills = 0;
                
                this.resize();
                this.loop();
                
                setInterval(() => { if(this.state === 'playing') { this.time++; this.updateTimerUI(); } }, 1000);
            },
            
            pause() {
                this.state = 'paused';
                document.getElementById('upgrade-modal').style.display = 'flex';
                this.generateUpgrades();
                AudioSys.play('levelup');
            },
            resume() {
                this.state = 'playing';
                document.getElementById('upgrade-modal').style.display = 'none';
                this.loop();
            },
            resize() { WIDTH = window.innerWidth; HEIGHT = window.innerHeight; canvas.width = WIDTH; canvas.height = HEIGHT; },
            
            loop() {
                if(this.state !== 'playing') return;
                this.frames++;
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            },
            
            update() {
                // ç”Ÿæˆ
                let spawnRate = 60; let speedMod = 1;
                if (this.difficulty === 'easy') spawnRate = 80;
                if (this.difficulty === 'hard') { spawnRate = 30; speedMod = 1.5; }
                spawnRate = Math.max(10, spawnRate - Math.floor(this.time / 10));

                if (this.frames % spawnRate === 0) this.spawnEnemy(speedMod);

                this.player.update();
                this.camera.x += (this.player.x - WIDTH/2 - this.camera.x) * 0.1;
                this.camera.y += (this.player.y - HEIGHT/2 - this.camera.y) * 0.1;

                this.enemies.forEach(e => e.update());
                this.bullets.forEach(b => b.update());
                this.xpGems.forEach(x => x.update());
                this.texts.forEach(t => t.update());

                // æ¸…ç†
                this.enemies = this.enemies.filter(e => !e.dead);
                this.bullets = this.bullets.filter(b => b.active); // ğŸ‘ˆ ä¿®å¤çš„ Bug åœ¨è¿™é‡Œ
                this.xpGems = this.xpGems.filter(x => !x.collected);
                this.texts = this.texts.filter(t => t.life > 0);

                this.checkCollisions();
            },

            draw() {
                ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.save();
                const cx = Math.floor(this.camera.x); const cy = Math.floor(this.camera.y);
                
                ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 2;
                const gridSize = 100;
                const offsetX = -cx % gridSize; const offsetY = -cy % gridSize;
                ctx.beginPath();
                for(let x=offsetX; x<WIDTH; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); }
                for(let y=offsetY; y<HEIGHT; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); }
                ctx.stroke();

                ctx.translate(-cx, -cy);

                this.xpGems.forEach(x => x.draw());
                this.player.draw();
                this.enemies.forEach(e => e.draw());
                this.bullets.forEach(b => b.draw());
                this.texts.forEach(t => t.draw());

                ctx.restore();
            },

            spawnEnemy(speedMod) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(WIDTH, HEIGHT) * 0.8;
                const x = this.player.x + Math.cos(angle) * dist;
                const y = this.player.y + Math.sin(angle) * dist;
                const hp = 10 + Math.floor(this.time / 30) * 5;
                this.enemies.push(new Enemy(x, y, hp, speedMod));
            },

            checkCollisions() {
                // å­å¼¹ -> æ€ª
                this.bullets.forEach(b => {
                    this.enemies.forEach(e => {
                        if (b.active && !e.dead && checkRectCollide(b, e)) {
                            if(b.type !== 'aura') b.active = false;
                            e.takeDamage(b.damage);
                        }
                    });
                });
                // äºº -> ç»éªŒ
                this.xpGems.forEach(g => {
                    const dist = Math.hypot(g.x - this.player.x, g.y - this.player.y);
                    if (dist < this.player.pickupRange) g.flyToPlayer();
                    if (dist < this.player.size) {
                        g.collected = true; this.player.gainXp(g.val); AudioSys.play('xp');
                    }
                });
                // æ€ª -> äºº
                this.enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    if (dist < this.player.size + e.size - 5) this.gameOver();
                });
            },
            
            generateUpgrades() {
                const box = document.getElementById('cards-box'); box.innerHTML = '';
                const pool = [...this.upgrades]; const choices = [];
                for(let i=0; i<3; i++) {
                    if(pool.length === 0) break;
                    const idx = Math.floor(Math.random() * pool.length);
                    choices.push(pool[idx]);
                }
                choices.forEach(u => {
                    const div = document.createElement('div'); div.className = 'upgrade-card';
                    div.innerHTML = `<div class="card-icon">${u.icon}</div><div class="card-info"><h3>${u.name}</h3><p>${u.desc}</p></div>`;
                    div.onclick = () => this.applyUpgrade(u);
                    box.appendChild(div);
                });
            },

            applyUpgrade(u) {
                if(u.type === 'stat') {
                    if(u.stat === 'fireRate') this.player.fireRate *= u.val;
                    else this.player[u.stat] += u.val;
                } else if (u.type === 'weapon') {
                    if(u.weapon === 'aura') {
                        if(!this.player.weapons.aura) this.player.weapons.aura = { active:true, size: 60, damage: 2 };
                        else { this.player.weapons.aura.size += 20; this.player.weapons.aura.damage += 1; }
                    }
                }
                this.resume();
            },
            
            updateTimerUI() {
                const m = Math.floor(this.time / 60).toString().padStart(2,'0');
                const s = (this.time % 60).toString().padStart(2,'0');
                document.getElementById('timer').innerText = `${m}:${s}`;
            },
            
            gameOver() {
                this.state = 'over';
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('end-time').innerText = document.getElementById('timer').innerText;
                document.getElementById('end-kills').innerText = this.kills;
                document.getElementById('end-level').innerText = this.player.level;
            }
        };

        function checkRectCollide(a, b) { return Math.abs(a.x - b.x) < (a.size + b.size)/2 && Math.abs(a.y - b.y) < (a.size + b.size)/2; }

        // --- å®ä½“ ---
        class Player {
            constructor() {
                this.x = 0; this.y = 0; this.size = 20; this.speed = 4;
                this.xp = 0; this.maxXp = 10; this.level = 1;
                this.fireRate = 40; this.fireTimer = 0; this.damage = 10;
                this.bulletCount = 1; this.pickupRange = 80;
                this.weapons = { aura: null }; this.facingRight = true;
            }
            update() {
                if (joystick.active) {
                    this.x += joystick.x * this.speed; this.y += joystick.y * this.speed;
                    this.facingRight = joystick.x > 0;
                }
                this.fireTimer--;
                if (this.fireTimer <= 0) { this.shoot(); this.fireTimer = this.fireRate; }
                if (this.weapons.aura && Game.frames % 10 === 0) {
                    Game.enemies.forEach(e => {
                        if(Math.hypot(e.x - this.x, e.y - this.y) < this.weapons.aura.size) e.takeDamage(this.weapons.aura.damage, false);
                    });
                }
            }
            shoot() {
                let target = null; let minDist = 400;
                Game.enemies.forEach(e => { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDist) { minDist = d; target = e; } });
                if (target) {
                    AudioSys.play('shoot');
                    for(let i=0; i<this.bulletCount; i++) {
                        setTimeout(() => {
                            const angle = Math.atan2(target.y - this.y, target.x - this.x) + (Math.random()-0.5)*0.2;
                            Game.bullets.push(new Bullet(this.x, this.y, angle, this.damage));
                        }, i * 100);
                    }
                }
            }
            gainXp(val) {
                this.xp += val;
                if (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp; this.level++; this.maxXp = Math.floor(this.maxXp * 1.2);
                    document.getElementById('level-val').innerText = this.level;
                    Game.pause();
                }
                document.getElementById('xp-bar').style.width = (this.xp / this.maxXp * 100) + '%';
            }
            draw() {
                if (this.weapons.aura) {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.weapons.aura.size, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.1)'; ctx.fill(); ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)'; ctx.stroke();
                }
                ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.save(); ctx.translate(this.x, this.y); if (!this.facingRight) ctx.scale(-1, 1);
                ctx.fillText('ğŸ¤ ', 0, 0); ctx.restore();
            }
        }

        class Enemy {
            constructor(x, y, hp, speedMod) {
                this.x = x; this.y = y; this.hp = hp; this.maxHp = hp;
                this.speed = (1 + Math.random()) * speedMod; this.size = 20;
                this.dead = false; this.emoji = ['ğŸ§Ÿ', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ‘»', 'ğŸ¦‡'][Math.floor(Math.random()*4)];
                this.hitFlash = 0;
            }
            update() {
                const dx = Game.player.x - this.x; const dy = Game.player.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
                if (this.hitFlash > 0) this.hitFlash--;
            }
            takeDamage(dmg, knockback=true) {
                this.hp -= dmg; this.hitFlash = 5;
                Game.texts.push(new FloatingText(this.x, this.y, Math.floor(dmg)));
                if(knockback) {
                    const angle = Math.atan2(this.y - Game.player.y, this.x - Game.player.x);
                    this.x += Math.cos(angle) * 10; this.y += Math.sin(angle) * 10;
                }
                if (this.hp <= 0) {
                    this.dead = true; Game.kills++; document.getElementById('kill-val').innerText = Game.kills;
                    Game.xpGems.push(new XpGem(this.x, this.y)); AudioSys.play('hit');
                }
            }
            draw() {
                ctx.font = '25px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.globalAlpha = this.hitFlash > 0 ? 0.5 : 1;
                ctx.save(); ctx.translate(this.x, this.y); if (this.x > Game.player.x) ctx.scale(-1, 1);
                ctx.fillText(this.emoji, 0, 0); ctx.restore(); ctx.globalAlpha = 1;
            }
        }

        class Bullet {
            constructor(x, y, angle, damage) {
                this.x = x; this.y = y;
                this.speed = 12; // é€Ÿåº¦å®šä¹‰è¦åœ¨ä½¿ç”¨å‰
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = damage;
                this.life = 60; this.active = true; this.size = 10;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; if(this.life <= 0) this.active = false; }
            draw() {
                ctx.fillStyle = '#4facfe'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(79, 172, 254, 0.3)'; ctx.beginPath(); ctx.arc(this.x - this.vx, this.y - this.vy, 3, 0, Math.PI*2); ctx.fill();
            }
        }

        class XpGem {
            constructor(x, y) { this.x = x; this.y = y; this.val = 2; this.collected = false; }
            update() {}
            flyToPlayer() {
                const dx = Game.player.x - this.x; const dy = Game.player.y - this.y;
                this.x += dx * 0.2; this.y += dy * 0.2;
            }
            draw() { ctx.font = '15px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ğŸ’', this.x, this.y); }
        }

        class FloatingText {
            constructor(x, y, text) { this.x = x; this.y = y; this.text = text; this.life = 30; }
            update() { this.y -= 1; this.life--; }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life/30})`;
                ctx.font = 'bold 12px Arial'; ctx.fillText(this.text, this.x, this.y);
            }
        }

        // --- æ‘‡æ† ---
        const stick = document.getElementById('stick');
        const stickBg = document.getElementById('stick-bg');
        const zone = document.getElementById('joystick-zone');
        const joystick = { x: 0, y: 0, active: false, originX: 0, originY: 0 };

        zone.addEventListener('touchstart', e => {
            e.preventDefault(); const t = e.touches[0]; joystick.active = true;
            joystick.originX = t.clientX; joystick.originY = t.clientY;
            stickBg.style.display = 'block'; stick.style.display = 'block';
            const r = zone.getBoundingClientRect();
            const relX = t.clientX - r.left; const relY = t.clientY - r.top;
            stickBg.style.left = relX+'px'; stickBg.style.top = relY+'px';
            stick.style.left = relX+'px'; stick.style.top = relY+'px';
        }, {passive: false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault(); if(!joystick.active) return;
            const t = e.touches[0];
            const dx = t.clientX - joystick.originX; const dy = t.clientY - joystick.originY;
            const dist = Math.hypot(dx, dy); const max = 50;
            const scale = Math.min(1, max / dist);
            const mx = dx * scale; const my = dy * scale;
            stick.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
            joystick.x = mx / max; joystick.y = my / max;
        }, {passive: false});

        const resetJoystick = () => { joystick.active = false; joystick.x=0; joystick.y=0; stickBg.style.display='none'; stick.style.display='none'; };
        zone.addEventListener('touchend', resetJoystick); zone.addEventListener('touchcancel', resetJoystick);

        window.addEventListener('resize', () => Game.resize()); Game.resize();

    </script>
</body>
</html>