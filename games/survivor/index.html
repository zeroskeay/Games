<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åƒµå°¸æ”¶å‰²æœºï¼šå¹¸å­˜è€…</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --accent: #e94560;
            --text: #fff;
            --xp: #0f3460;
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: 'Segoe UI', sans-serif; user-select: none;
            touch-action: none; color: var(--text);
        }

        canvas { display: block; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* é¡¶éƒ¨ HUD */
        .hud {
            padding: 15px; display: flex; justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }
        .bar-container {
            flex: 1; margin: 0 15px; height: 20px; background: #333;
            border-radius: 10px; overflow: hidden; position: relative;
            border: 2px solid #555;
        }
        #xp-bar {
            width: 0%; height: 100%; background: #4facfe;
            transition: width 0.2s;
        }
        .level-badge {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            font-size: 0.8rem; font-weight: bold; text-shadow: 1px 1px 0 #000;
        }

        /* å¯åŠ¨/éš¾åº¦é€‰æ‹© */
        #start-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; pointer-events: auto;
        }
        .title { font-size: 2.5rem; color: var(--accent); margin-bottom: 30px; text-shadow: 0 0 20px var(--accent); text-align: center;}
        .diff-btn {
            background: #16213e; color: #fff; border: 2px solid #0f3460;
            width: 200px; padding: 15px; margin: 10px; font-size: 1.2rem;
            cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: space-between; align-items: center;
        }
        .diff-btn:active { transform: scale(0.95); background: var(--accent); }
        .diff-icon { font-size: 1.5rem; }

        /* å‡çº§å¼¹çª— */
        #upgrade-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .card-container {
            display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px;
        }
        .upgrade-card {
            background: linear-gradient(45deg, #16213e, #1a1a2e);
            border: 2px solid #4facfe; border-radius: 12px;
            padding: 15px; cursor: pointer; display: flex; align-items: center; gap: 15px;
            transition: transform 0.1s;
        }
        .upgrade-card:active { transform: scale(0.98); background: #4facfe; color: #000; }
        .card-icon { font-size: 2.5rem; }
        .card-info h3 { margin: 0 0 5px 0; font-size: 1.1rem; color: #ffd700; }
        .card-info p { margin: 0; font-size: 0.85rem; color: #ccc; }

        /* è™šæ‹Ÿæ‘‡æ† */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 200px; pointer-events: auto;
            /* éšå½¢è§¦æ‘¸åŒº */
        }
        #stick-bg {
            position: absolute; width: 100px; height: 100px; background: rgba(255,255,255,0.1);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;
        }
        #stick {
            position: absolute; width: 40px; height: 40px; background: var(--accent);
            border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: none; box-shadow: 0 0 10px var(--accent);
        }

        /* æ­»äº¡/é€šå…³ */
        #game-over {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 300; pointer-events: auto;
        }
        .stat-box { text-align: center; margin-bottom: 30px; line-height: 1.8; color: #ccc; }
        .big-num { font-size: 1.5rem; color: #fff; font-weight: bold; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div>â±ï¸ <span id="timer">00:00</span></div>
            <div class="bar-container">
                <div id="xp-bar"></div>
                <div class="level-badge">LV <span id="level-val">1</span></div>
            </div>
            <div>ğŸ’€ <span id="kill-val">0</span></div>
        </div>

        <div id="joystick-zone">
            <div id="stick-bg"><div id="stick"></div></div>
        </div>
    </div>

    <div id="start-screen">
        <div class="title">ğŸ§Ÿ åƒµå°¸æ”¶å‰²æœº<br><span style="font-size:1rem; color:#fff; opacity:0.7">SURVIVOR</span></div>
        <div class="diff-btn" onclick="Game.start('easy')">
            <span class="diff-icon">ğŸ‘¶</span>
            <div>
                <div>èœé¸Ÿæ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">åƒµå°¸å¾ˆæ…¢ï¼Œé€‚åˆçƒ­æ‰‹</div>
            </div>
        </div>
        <div class="diff-btn" onclick="Game.start('normal')">
            <span class="diff-icon">ğŸ’€</span>
            <div>
                <div>è€å…µæ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">æ ‡å‡†é€Ÿåº¦ï¼Œæ€ªæ½®æ±¹æ¶Œ</div>
            </div>
        </div>
        <div class="diff-btn" onclick="Game.start('hard')">
            <span class="diff-icon">ğŸ‘¹</span>
            <div>
                <div>åœ°ç‹±æ¨¡å¼</div>
                <div style="font-size:0.7rem; opacity:0.7">æå¿«é€Ÿåº¦ï¼Œç”Ÿå­˜æŒ‘æˆ˜</div>
            </div>
        </div>
    </div>

    <div id="upgrade-modal">
        <h2 style="color:#fff; margin-bottom:20px;">å‡çº§å•¦ï¼é€‰æ‹©å¥–åŠ±</h2>
        <div class="card-container" id="cards-box">
            </div>
    </div>

    <div id="game-over">
        <h1 id="end-title" style="color: #e94560; font-size: 3rem; margin-bottom: 10px;">ä½ æŒ‚äº†</h1>
        <div class="stat-box">
            å­˜æ´»æ—¶é—´ <div class="big-num" id="end-time">00:00</div><br>
            å‡»æ€åƒµå°¸ <div class="big-num" id="end-kills">0</div><br>
            æœ€ç»ˆç­‰çº§ <div class="big-num" id="end-level">1</div>
        </div>
        <div class="diff-btn" style="justify-content: center;" onclick="location.reload()">å†æ¥ä¸€å±€</div>
    </div>

    <script>
        // --- ğŸ”Š éŸ³æ•ˆç³»ç»Ÿ ---
        const AudioSys = {
            ctx: null,
            init() {
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play(type) {
                if(!this.ctx) return;
                if(this.ctx.state === 'suspended') this.ctx.resume();
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                const now = this.ctx.currentTime;

                switch(type) {
                    case 'shoot': // é­”æ³•å¼¹
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now); osc.stop(now + 0.1);
                        break;
                    case 'hit': // å‡»ä¸­/æ­»äº¡
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100 + Math.random()*50, now);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now); osc.stop(now + 0.1);
                        break;
                    case 'xp': // æ¡ç»éªŒ
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                        gain.gain.setValueAtTime(0.05, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now); osc.stop(now + 0.1);
                        break;
                    case 'levelup': // å‡çº§ (å’Œå¼¦)
                        [440, 554, 659].forEach((f, i) => {
                            const o = this.ctx.createOscillator();
                            const g = this.ctx.createGain();
                            o.type = 'square';
                            o.frequency.value = f;
                            g.gain.setValueAtTime(0.1, now + i*0.1);
                            g.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.5);
                            o.connect(g); g.connect(this.ctx.destination);
                            o.start(now + i*0.1); o.stop(now + i*0.1 + 0.5);
                        });
                        break;
                }
            }
        };

        // --- ğŸ› ï¸ æ¸¸æˆå¼•æ“ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let WIDTH, HEIGHT;

        const Game = {
            state: 'menu', // menu, playing, paused, over
            frames: 0,
            time: 0, // ç§’
            kills: 0,
            difficulty: 'normal',
            
            player: null,
            enemies: [],
            xpGems: [],
            bullets: [],
            texts: [], // é£˜å­—
            
            camera: {x:0, y:0},
            
            // æŠ€èƒ½æ± 
            upgrades: [
                { id: 'speed', name: 'ç–¾é£æ­¥', desc: 'ç§»åŠ¨é€Ÿåº¦ +20%', icon: 'ğŸ‘Ÿ', type: 'stat', stat: 'speed', val: 1 },
                { id: 'rate', name: 'å¿«æªæ‰‹', desc: 'å°„å‡»é¢‘ç‡ +20%', icon: 'âš¡', type: 'stat', stat: 'fireRate', val: 0.8 }, // é—´éš”å˜å°
                { id: 'damage', name: 'å¼ºåŠ›å¼¹', desc: 'å­å¼¹ä¼¤å®³ +5', icon: 'ğŸ’¥', type: 'stat', stat: 'damage', val: 5 },
                { id: 'multi', name: 'å¤šé‡å°„å‡»', desc: 'å­å¼¹æ•°é‡ +1', icon: 'ğŸ’', type: 'stat', stat: 'bulletCount', val: 1 },
                { id: 'aura', name: 'å¤§è’œå…‰ç¯', desc: 'è·å¾—ä¼¤å®³å…‰ç¯/èŒƒå›´å˜å¤§', icon: 'ğŸ§„', type: 'weapon', weapon: 'aura' }
            ],

            start(diff) {
                AudioSys.init();
                this.difficulty = diff;
                this.state = 'playing';
                document.getElementById('start-screen').style.display = 'none';
                
                this.player = new Player();
                this.enemies = [];
                this.xpGems = [];
                this.bullets = [];
                this.texts = [];
                this.frames = 0;
                this.time = 0;
                this.kills = 0;
                
                this.resize();
                this.loop();
                
                // è®¡æ—¶å™¨
                setInterval(() => {
                    if(this.state === 'playing') {
                        this.time++;
                        this.updateTimerUI();
                    }
                }, 1000);
            },
            
            pause() {
                this.state = 'paused';
                document.getElementById('upgrade-modal').style.display = 'flex';
                this.generateUpgrades();
                AudioSys.play('levelup');
            },
            
            resume() {
                this.state = 'playing';
                document.getElementById('upgrade-modal').style.display = 'none';
                this.loop();
            },

            resize() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                canvas.width = WIDTH;
                canvas.height = HEIGHT;
            },
            
            loop() {
                if(this.state !== 'playing') return;
                
                this.frames++;
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            },
            
            update() {
                // 1. ç”Ÿæˆæ•Œäºº
                let spawnRate = 60; // é»˜è®¤1ç§’ä¸€ä¸ª
                let speedMod = 1;
                if (this.difficulty === 'easy') spawnRate = 80;
                if (this.difficulty === 'hard') { spawnRate = 30; speedMod = 1.5; }
                
                // éšç€æ—¶é—´æ¨ç§»ï¼Œæ€ªè¶Šæ¥è¶Šå¤š
                spawnRate = Math.max(10, spawnRate - Math.floor(this.time / 10));

                if (this.frames % spawnRate === 0) {
                    this.spawnEnemy(speedMod);
                }

                // 2. å®ä½“æ›´æ–°
                this.player.update();
                
                // ç›¸æœºè·Ÿéš (å¹³æ»‘)
                this.camera.x += (this.player.x - WIDTH/2 - this.camera.x) * 0.1;
                this.camera.y += (this.player.y - HEIGHT/2 - this.camera.y) * 0.1;

                this.enemies.forEach(e => e.update());
                this.bullets.forEach(b => b.update());
                this.xpGems.forEach(x => x.update());
                this.texts.forEach(t => t.update());

                // 3. æ¸…ç†
                this.enemies = this.enemies.filter(e => !e.dead);
                this.bullets = this.bullets.filter(b => !b.active);
                this.xpGems = this.xpGems.filter(x => !x.collected);
                this.texts = this.texts.filter(t => t.life > 0);

                // 4. ç¢°æ’æ£€æµ‹
                this.checkCollisions();
            },

            draw() {
                // èƒŒæ™¯ (ç”»ç½‘æ ¼ä»¥ä½“ç°ç§»åŠ¨)
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                
                ctx.save();
                // åç§»ç›¸æœº
                // å–æ•´é˜²æ­¢æ¨¡ç³Š
                const cx = Math.floor(this.camera.x); 
                const cy = Math.floor(this.camera.y);
                
                // ç”»ç½‘æ ¼çº¿
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 2;
                const gridSize = 100;
                const offsetX = -cx % gridSize;
                const offsetY = -cy % gridSize;
                
                ctx.beginPath();
                for(let x=offsetX; x<WIDTH; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); }
                for(let y=offsetY; y<HEIGHT; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); }
                ctx.stroke();

                // æ‰€æœ‰çš„ç»˜åˆ¶éƒ½éœ€è¦å‡å» cx, cy
                ctx.translate(-cx, -cy);

                this.xpGems.forEach(x => x.draw());
                this.player.draw();
                this.enemies.forEach(e => e.draw());
                this.bullets.forEach(b => b.draw());
                this.texts.forEach(t => t.draw());

                ctx.restore();
            },

            spawnEnemy(speedMod) {
                // åœ¨å±å¹•å¤–ç”Ÿæˆ
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(WIDTH, HEIGHT) * 0.8; // ç¨å¾®è¿œä¸€ç‚¹
                const x = this.player.x + Math.cos(angle) * dist;
                const y = this.player.y + Math.sin(angle) * dist;
                
                // éšæ—¶é—´å˜å¼º
                const hp = 10 + Math.floor(this.time / 30) * 5;
                this.enemies.push(new Enemy(x, y, hp, speedMod));
            },

            checkCollisions() {
                // å­å¼¹æ‰“æ€ª
                this.bullets.forEach(b => {
                    this.enemies.forEach(e => {
                        if (b.active && !e.dead && checkRectCollide(b, e)) {
                            if(b.type !== 'aura') b.active = false; // å…‰ç¯ä¸æ¶ˆå¤±
                            // ä¼¤å®³åˆ¤æ–­ (ç®€å•çš„æ— æ•Œå¸§é€»è¾‘åœ¨Enemyé‡Œ)
                            e.takeDamage(b.damage);
                        }
                    });
                });

                // äººåƒç»éªŒ
                this.xpGems.forEach(g => {
                    const dist = Math.hypot(g.x - this.player.x, g.y - this.player.y);
                    if (dist < this.player.pickupRange) {
                        g.flyToPlayer();
                    }
                    if (dist < this.player.size) {
                        g.collected = true;
                        this.player.gainXp(g.val);
                        AudioSys.play('xp');
                    }
                });

                // æ€ªæ‰“äºº
                this.enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    if (dist < this.player.size + e.size - 5) {
                        this.gameOver();
                    }
                });
            },
            
            generateUpgrades() {
                const box = document.getElementById('cards-box');
                box.innerHTML = '';
                // éšæœºé€‰3ä¸ªä¸é‡å¤çš„
                const pool = [...this.upgrades];
                const choices = [];
                for(let i=0; i<3; i++) {
                    if(pool.length === 0) break;
                    const idx = Math.floor(Math.random() * pool.length);
                    choices.push(pool[idx]);
                    // ä¸ç§»é™¤ï¼Œå…è®¸é‡å¤å‡ºç°å±æ€§å‡çº§ï¼Œä½†å¦‚æœæ˜¯è§£é”ç±»æ­¦å™¨å¯ä»¥ç§»é™¤
                    // ç®€å•èµ·è§ä¸ç§»é™¤
                }

                choices.forEach(u => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-card';
                    div.innerHTML = `
                        <div class="card-icon">${u.icon}</div>
                        <div class="card-info">
                            <h3>${u.name}</h3>
                            <p>${u.desc}</p>
                        </div>
                    `;
                    div.onclick = () => this.applyUpgrade(u);
                    box.appendChild(div);
                });
            },

            applyUpgrade(u) {
                if(u.type === 'stat') {
                    if(u.stat === 'fireRate') this.player.fireRate *= u.val;
                    else this.player[u.stat] += u.val;
                } else if (u.type === 'weapon') {
                    if(u.weapon === 'aura') {
                        if(!this.player.weapons.aura) this.player.weapons.aura = { active:true, size: 60, damage: 2 };
                        else {
                            this.player.weapons.aura.size += 20;
                            this.player.weapons.aura.damage += 1;
                        }
                    }
                }
                this.resume();
            },
            
            updateTimerUI() {
                const m = Math.floor(this.time / 60).toString().padStart(2,'0');
                const s = (this.time % 60).toString().padStart(2,'0');
                document.getElementById('timer').innerText = `${m}:${s}`;
            },
            
            gameOver() {
                this.state = 'over';
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('end-time').innerText = document.getElementById('timer').innerText;
                document.getElementById('end-kills').innerText = this.kills;
                document.getElementById('end-level').innerText = this.player.level;
            }
        };

        function checkRectCollide(a, b) {
            return Math.abs(a.x - b.x) < (a.size + b.size)/2 && Math.abs(a.y - b.y) < (a.size + b.size)/2;
        }

        // --- ğŸ¤º è§’è‰²ç±» ---
        class Player {
            constructor() {
                this.x = 0; this.y = 0;
                this.size = 20;
                this.speed = 4;
                this.xp = 0;
                this.maxXp = 10;
                this.level = 1;
                
                // æˆ˜æ–—å±æ€§
                this.fireRate = 40; // å¸§æ•°é—´éš”
                this.fireTimer = 0;
                this.damage = 10;
                this.bulletCount = 1;
                this.pickupRange = 80;
                
                this.weapons = { aura: null }; // æ­¦å™¨æ§½
                
                // ç§»åŠ¨å‘é‡
                this.vx = 0; this.vy = 0;
            }

            update() {
                // ç§»åŠ¨
                if (joystick.active) {
                    this.x += joystick.x * this.speed;
                    this.y += joystick.y * this.speed;
                    // ç®€å•çš„ç¿»è½¬æœå‘
                    this.facingRight = joystick.x > 0;
                }

                // è‡ªåŠ¨æ”»å‡» (æœ€è¿‘çš„æ•Œäºº)
                this.fireTimer--;
                if (this.fireTimer <= 0) {
                    this.shoot();
                    this.fireTimer = this.fireRate;
                }
                
                // å…‰ç¯æ”»å‡»
                if (this.weapons.aura) {
                    // æ¯ä¸€å¸§éƒ½å¯¹å…‰ç¯å†…çš„æ•Œäººé€ æˆå¾®é‡ä¼¤å®³
                    if(Game.frames % 10 === 0) {
                        Game.enemies.forEach(e => {
                            const dist = Math.hypot(e.x - this.x, e.y - this.y);
                            if(dist < this.weapons.aura.size) {
                                e.takeDamage(this.weapons.aura.damage, false); // å…‰ç¯ä¸å‡»é€€
                            }
                        });
                    }
                }
            }
            
            shoot() {
                // æ‰¾æœ€è¿‘çš„æ•Œäºº
                let target = null;
                let minDist = 400; // å°„ç¨‹
                Game.enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) { minDist = d; target = e; }
                });
                
                if (target) {
                    AudioSys.play('shoot');
                    // å‘å°„å¤šé‡å­å¼¹
                    for(let i=0; i<this.bulletCount; i++) {
                        setTimeout(() => {
                            // ç¨å¾®åè½¬ä¸€ç‚¹è§’åº¦
                            const angle = Math.atan2(target.y - this.y, target.x - this.x) + (Math.random()-0.5)*0.2;
                            Game.bullets.push(new Bullet(this.x, this.y, angle, this.damage));
                        }, i * 100);
                    }
                }
            }

            gainXp(val) {
                this.xp += val;
                if (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp;
                    this.level++;
                    this.maxXp = Math.floor(this.maxXp * 1.2);
                    document.getElementById('level-val').innerText = this.level;
                    Game.pause();
                }
                // æ›´æ–°UIæ¡
                document.getElementById('xp-bar').style.width = (this.xp / this.maxXp * 100) + '%';
            }

            draw() {
                // ç»˜åˆ¶å…‰ç¯
                if (this.weapons.aura) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.weapons.aura.size, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.stroke();
                }

                // ç»˜åˆ¶äººç‰© (Emoji)
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.save();
                ctx.translate(this.x, this.y);
                if (!this.facingRight) ctx.scale(-1, 1); // é•œåƒç¿»è½¬
                ctx.fillText('ğŸ¤ ', 0, 0);
                ctx.restore();
            }
        }

        // --- ğŸ§Ÿ æ•Œäººç±» ---
        class Enemy {
            constructor(x, y, hp, speedMod) {
                this.x = x; this.y = y;
                this.hp = hp;
                this.maxHp = hp;
                this.speed = (1 + Math.random()) * speedMod;
                this.size = 20;
                this.dead = false;
                this.emoji = ['ğŸ§Ÿ', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ‘»', 'ğŸ¦‡'][Math.floor(Math.random()*4)];
                this.hitFlash = 0;
            }
            update() {
                // è¿½é€ç©å®¶
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                if (this.hitFlash > 0) this.hitFlash--;
            }
            takeDamage(dmg, knockback=true) {
                this.hp -= dmg;
                this.hitFlash = 5;
                Game.texts.push(new FloatingText(this.x, this.y, Math.floor(dmg)));
                
                if(knockback) {
                    // ç®€å•å‡»é€€
                    const angle = Math.atan2(this.y - Game.player.y, this.x - Game.player.x);
                    this.x += Math.cos(angle) * 10;
                    this.y += Math.sin(angle) * 10;
                }

                if (this.hp <= 0) {
                    this.dead = true;
                    Game.kills++;
                    document.getElementById('kill-val').innerText = Game.kills;
                    Game.xpGems.push(new XpGem(this.x, this.y));
                    AudioSys.play('hit');
                }
            }
            draw() {
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = this.hitFlash > 0 ? 0.5 : 1;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.x > Game.player.x) ctx.scale(-1, 1);
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        // --- ğŸ”® æ‰è½ç‰©ä¸å­å¼¹ ---
        class Bullet {
            constructor(x, y, angle, damage) {
                this.x = x; this.y = y;
                this.speed = 12;
                this.damage = damage;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.life = 60; // å­˜åœ¨æ—¶é—´
                this.active = true;
                this.size = 10;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                if(this.life <= 0) this.active = false;
            }
            draw() {
                ctx.fillStyle = '#4facfe';
                ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                // æ‹–å°¾
                ctx.fillStyle = 'rgba(79, 172, 254, 0.3)';
                ctx.beginPath(); ctx.arc(this.x - this.vx, this.y - this.vy, 3, 0, Math.PI*2); ctx.fill();
            }
        }

        class XpGem {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.val = 2;
                this.collected = false;
                this.flying = false;
            }
            update() {} // é™æ€ï¼Œé™¤éè¢«å¸é™„
            flyToPlayer() {
                this.flying = true;
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                this.x += dx * 0.2;
                this.y += dy * 0.2;
            }
            draw() {
                ctx.font = '15px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸ’', this.x, this.y);
            }
        }

        class FloatingText {
            constructor(x, y, text) {
                this.x = x; this.y = y; this.text = text;
                this.life = 30;
            }
            update() { this.y -= 1; this.life--; }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life/30})`;
                ctx.font = 'bold 12px Arial';
                ctx.fillText(this.text, this.x, this.y);
            }
        }

        // --- ğŸ•¹ï¸ æ‘‡æ†æ§åˆ¶ ---
        const stick = document.getElementById('stick');
        const stickBg = document.getElementById('stick-bg');
        const zone = document.getElementById('joystick-zone');
        const joystick = { x: 0, y: 0, active: false, originX: 0, originY: 0 };

        zone.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.touches[0];
            joystick.active = true;
            joystick.originX = t.clientX;
            joystick.originY = t.clientY;
            
            stickBg.style.display = 'block';
            stick.style.display = 'block';
            // å°†æ‘‡æ†è§†è§‰å®šä½åˆ°æ‰‹æŒ‡ä½ç½®
            const rect = zone.getBoundingClientRect();
            const relX = t.clientX - rect.left;
            const relY = t.clientY - rect.top;
            stickBg.style.left = relX + 'px';
            stickBg.style.top = relY + 'px';
            stick.style.left = relX + 'px';
            stick.style.top = relY + 'px';
        }, {passive: false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault();
            if(!joystick.active) return;
            const t = e.touches[0];
            const dx = t.clientX - joystick.originX;
            const dy = t.clientY - joystick.originY;
            const dist = Math.hypot(dx, dy);
            const maxDist = 50;
            
            const scale = Math.min(1, maxDist / dist);
            const moveX = dx * scale || 0; // fix NaN if dist 0
            const moveY = dy * scale || 0;
            
            // è§†è§‰ç§»åŠ¨
            stick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
            
            // é€»è¾‘è¾“å‡º (-1 to 1)
            joystick.x = moveX / maxDist;
            joystick.y = moveY / maxDist;
        }, {passive: false});

        const resetJoystick = () => {
            joystick.active = false;
            joystick.x = 0; joystick.y = 0;
            stickBg.style.display = 'none';
            stick.style.display = 'none';
        };
        zone.addEventListener('touchend', resetJoystick);
        zone.addEventListener('touchcancel', resetJoystick);

        // çª—å£å¤§å°æ”¹å˜
        window.addEventListener('resize', () => Game.resize());
        Game.resize();

    </script>
</body>
</html>